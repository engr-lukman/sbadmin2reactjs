{"ast":null,"code":"/* @license\nmorris.js v0.5.1\nCopyright 2014 Olly Smith All rights reserved.\nLicensed under the BSD-2-Clause License.\n*/\n(function () {\n  var a,\n      b,\n      c,\n      d,\n      e = [].slice,\n      f = function f(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  },\n      g = {}.hasOwnProperty,\n      h = function h(a, b) {\n    function c() {\n      this.constructor = a;\n    }\n\n    for (var d in b) {\n      g.call(b, d) && (a[d] = b[d]);\n    }\n\n    return c.prototype = b.prototype, a.prototype = new c(), a.__super__ = b.prototype, a;\n  },\n      i = [].indexOf || function (a) {\n    for (var b = 0, c = this.length; c > b; b++) {\n      if (b in this && this[b] === a) return b;\n    }\n\n    return -1;\n  };\n\n  b = window.Morris = {}, a = jQuery, b.EventEmitter = function () {\n    function a() {}\n\n    return a.prototype.on = function (a, b) {\n      return null == this.handlers && (this.handlers = {}), null == this.handlers[a] && (this.handlers[a] = []), this.handlers[a].push(b), this;\n    }, a.prototype.fire = function () {\n      var a, b, c, d, f, g, h;\n\n      if (c = arguments[0], a = 2 <= arguments.length ? e.call(arguments, 1) : [], null != this.handlers && null != this.handlers[c]) {\n        for (g = this.handlers[c], h = [], d = 0, f = g.length; f > d; d++) {\n          b = g[d], h.push(b.apply(null, a));\n        }\n\n        return h;\n      }\n    }, a;\n  }(), b.commas = function (a) {\n    var b, c, d, e;\n    return null != a ? (d = 0 > a ? \"-\" : \"\", b = Math.abs(a), c = Math.floor(b).toFixed(0), d += c.replace(/(?=(?:\\d{3})+$)(?!^)/g, \",\"), e = b.toString(), e.length > c.length && (d += e.slice(c.length)), d) : \"-\";\n  }, b.pad2 = function (a) {\n    return (10 > a ? \"0\" : \"\") + a;\n  }, b.Grid = function (c) {\n    function d(b) {\n      this.hasToShow = f(this.hasToShow, this), this.resizeHandler = f(this.resizeHandler, this);\n      var c = this;\n      if (this.el = a(\"string\" == typeof b.element ? document.getElementById(b.element) : b.element), null == this.el || 0 === this.el.length) throw new Error(\"Graph container element not found\");\n      \"static\" === this.el.css(\"position\") && this.el.css(\"position\", \"relative\"), this.options = a.extend({}, this.gridDefaults, this.defaults || {}, b), \"string\" == typeof this.options.units && (this.options.postUnits = b.units), this.raphael = new Raphael(this.el[0]), this.elementWidth = null, this.elementHeight = null, this.dirty = !1, this.selectFrom = null, this.init && this.init(), this.setData(this.options.data), this.el.bind(\"mousemove\", function (a) {\n        var b, d, e, f, g;\n        return d = c.el.offset(), g = a.pageX - d.left, c.selectFrom ? (b = c.data[c.hitTest(Math.min(g, c.selectFrom))]._x, e = c.data[c.hitTest(Math.max(g, c.selectFrom))]._x, f = e - b, c.selectionRect.attr({\n          x: b,\n          width: f\n        })) : c.fire(\"hovermove\", g, a.pageY - d.top);\n      }), this.el.bind(\"mouseleave\", function () {\n        return c.selectFrom && (c.selectionRect.hide(), c.selectFrom = null), c.fire(\"hoverout\");\n      }), this.el.bind(\"touchstart touchmove touchend\", function (a) {\n        var b, d;\n        return d = a.originalEvent.touches[0] || a.originalEvent.changedTouches[0], b = c.el.offset(), c.fire(\"hovermove\", d.pageX - b.left, d.pageY - b.top);\n      }), this.el.bind(\"click\", function (a) {\n        var b;\n        return b = c.el.offset(), c.fire(\"gridclick\", a.pageX - b.left, a.pageY - b.top);\n      }), this.options.rangeSelect && (this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({\n        fill: this.options.rangeSelectColor,\n        stroke: !1\n      }).toBack().hide(), this.el.bind(\"mousedown\", function (a) {\n        var b;\n        return b = c.el.offset(), c.startRange(a.pageX - b.left);\n      }), this.el.bind(\"mouseup\", function (a) {\n        var b;\n        return b = c.el.offset(), c.endRange(a.pageX - b.left), c.fire(\"hovermove\", a.pageX - b.left, a.pageY - b.top);\n      })), this.options.resize && a(window).bind(\"resize\", function () {\n        return null != c.timeoutId && window.clearTimeout(c.timeoutId), c.timeoutId = window.setTimeout(c.resizeHandler, 100);\n      }), this.el.css(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\"), this.postInit && this.postInit();\n    }\n\n    return h(d, c), d.prototype.gridDefaults = {\n      dateFormat: null,\n      axes: !0,\n      grid: !0,\n      gridLineColor: \"#aaa\",\n      gridStrokeWidth: .5,\n      gridTextColor: \"#888\",\n      gridTextSize: 12,\n      gridTextFamily: \"sans-serif\",\n      gridTextWeight: \"normal\",\n      hideHover: !1,\n      yLabelFormat: null,\n      xLabelAngle: 0,\n      numLines: 5,\n      padding: 25,\n      parseTime: !0,\n      postUnits: \"\",\n      preUnits: \"\",\n      ymax: \"auto\",\n      ymin: \"auto 0\",\n      goals: [],\n      goalStrokeWidth: 1,\n      goalLineColors: [\"#666633\", \"#999966\", \"#cc6666\", \"#663333\"],\n      events: [],\n      eventStrokeWidth: 1,\n      eventLineColors: [\"#005a04\", \"#ccffbb\", \"#3a5f0b\", \"#005502\"],\n      rangeSelect: null,\n      rangeSelectColor: \"#eef\",\n      resize: !1\n    }, d.prototype.setData = function (c, d) {\n      var e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y;\n      if (null == d && (d = !0), this.options.data = c, null == c || 0 === c.length) return this.data = [], this.raphael.clear(), void (null != this.hover && this.hover.hide());\n\n      if (s = this.cumulative ? 0 : null, t = this.cumulative ? 0 : null, this.options.goals.length > 0 && (k = Math.min.apply(Math, this.options.goals), j = Math.max.apply(Math, this.options.goals), t = null != t ? Math.min(t, k) : k, s = null != s ? Math.max(s, j) : j), this.data = function () {\n        var a, d, e;\n\n        for (e = [], i = a = 0, d = c.length; d > a; i = ++a) {\n          m = c[i], l = {\n            src: m\n          }, l.label = m[this.options.xkey], this.options.parseTime ? (l.x = b.parseDate(l.label), this.options.dateFormat ? l.label = this.options.dateFormat(l.x) : \"number\" == typeof l.label && (l.label = new Date(l.label).toString())) : (l.x = i, this.options.xLabelFormat && (l.label = this.options.xLabelFormat(l))), p = 0, l.y = function () {\n            var a, b, c, d;\n\n            for (c = this.options.ykeys, d = [], h = a = 0, b = c.length; b > a; h = ++a) {\n              r = c[h], u = m[r], \"string\" == typeof u && (u = parseFloat(u)), null != u && \"number\" != typeof u && (u = null), null != u && this.hasToShow(h) && (this.cumulative ? p += u : null != s ? (s = Math.max(u, s), t = Math.min(u, t)) : s = t = u), this.cumulative && null != p && (s = Math.max(p, s), t = Math.min(p, t)), d.push(u);\n            }\n\n            return d;\n          }.call(this), e.push(l);\n        }\n\n        return e;\n      }.call(this), this.options.parseTime && (this.data = this.data.sort(function (a, b) {\n        return (a.x > b.x) - (b.x > a.x);\n      })), this.xmin = this.data[0].x, this.xmax = this.data[this.data.length - 1].x, this.events = [], this.options.events.length > 0) {\n        if (this.options.parseTime) for (x = this.options.events, v = 0, w = x.length; w > v; v++) {\n          e = x[v], e instanceof Array ? (g = e[0], o = e[1], this.events.push([b.parseDate(g), b.parseDate(o)])) : this.events.push(b.parseDate(e));\n        } else this.events = this.options.events;\n        f = a.map(this.events, function (a) {\n          return a;\n        }), this.xmax = Math.max(this.xmax, Math.max.apply(Math, f)), this.xmin = Math.min(this.xmin, Math.min.apply(Math, f));\n      }\n\n      return this.xmin === this.xmax && (this.xmin -= 1, this.xmax += 1), this.ymin = this.yboundary(\"min\", t), this.ymax = this.yboundary(\"max\", s), this.ymin === this.ymax && (t && (this.ymin -= 1), this.ymax += 1), ((y = this.options.axes) === !0 || \"both\" === y || \"y\" === y || this.options.grid === !0) && (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin ? (this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines), this.ymin = Math.min(this.ymin, this.grid[0]), this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1])) : (n = (this.ymax - this.ymin) / (this.options.numLines - 1), this.grid = function () {\n        var a, b, c, d;\n\n        for (d = [], q = a = b = this.ymin, c = this.ymax; n > 0 ? c >= a : a >= c; q = a += n) {\n          d.push(q);\n        }\n\n        return d;\n      }.call(this))), this.dirty = !0, d ? this.redraw() : void 0;\n    }, d.prototype.yboundary = function (a, b) {\n      var c, d;\n      return c = this.options[\"y\" + a], \"string\" == typeof c ? \"auto\" === c.slice(0, 4) ? c.length > 5 ? (d = parseInt(c.slice(5), 10), null == b ? d : Math[a](b, d)) : null != b ? b : 0 : parseInt(c, 10) : c;\n    }, d.prototype.autoGridLines = function (a, b, c) {\n      var d, e, f, g, h, i, j, k, l;\n      return h = b - a, l = Math.floor(Math.log(h) / Math.log(10)), j = Math.pow(10, l), e = Math.floor(a / j) * j, d = Math.ceil(b / j) * j, i = (d - e) / (c - 1), 1 === j && i > 1 && Math.ceil(i) !== i && (i = Math.ceil(i), d = e + i * (c - 1)), 0 > e && d > 0 && (e = Math.floor(a / i) * i, d = Math.ceil(b / i) * i), 1 > i ? (g = Math.floor(Math.log(i) / Math.log(10)), f = function () {\n        var a, b;\n\n        for (b = [], k = a = e; i > 0 ? d >= a : a >= d; k = a += i) {\n          b.push(parseFloat(k.toFixed(1 - g)));\n        }\n\n        return b;\n      }()) : f = function () {\n        var a, b;\n\n        for (b = [], k = a = e; i > 0 ? d >= a : a >= d; k = a += i) {\n          b.push(k);\n        }\n\n        return b;\n      }(), f;\n    }, d.prototype._calc = function () {\n      var a, b, c, d, e, f, g, h, i;\n      return f = this.el.width(), d = this.el.height(), (this.elementWidth !== f || this.elementHeight !== d || this.dirty) && (this.elementWidth = f, this.elementHeight = d, this.dirty = !1, this.left = this.options.padding, this.right = this.elementWidth - this.options.padding, this.top = this.options.padding, this.bottom = this.elementHeight - this.options.padding, ((h = this.options.axes) === !0 || \"both\" === h || \"y\" === h) && (g = function () {\n        var a, b, d, e;\n\n        for (d = this.grid, e = [], a = 0, b = d.length; b > a; a++) {\n          c = d[a], e.push(this.measureText(this.yAxisFormat(c)).width);\n        }\n\n        return e;\n      }.call(this), this.options.horizontal ? this.bottom -= Math.max.apply(Math, g) : this.left += Math.max.apply(Math, g)), ((i = this.options.axes) === !0 || \"both\" === i || \"x\" === i) && (a = this.options.horizontal ? -90 : -this.options.xLabelAngle, b = function () {\n        var b, c, d;\n\n        for (d = [], e = b = 0, c = this.data.length; c >= 0 ? c > b : b > c; e = c >= 0 ? ++b : --b) {\n          d.push(this.measureText(this.data[e].label, a).height);\n        }\n\n        return d;\n      }.call(this), this.options.horizontal ? this.left += Math.max.apply(Math, b) : this.bottom -= Math.max.apply(Math, b)), this.width = Math.max(1, this.right - this.left), this.height = Math.max(1, this.bottom - this.top), this.options.horizontal ? (this.dx = this.height / (this.xmax - this.xmin), this.dy = this.width / (this.ymax - this.ymin), this.yStart = this.left, this.yEnd = this.right, this.xStart = this.top, this.xEnd = this.bottom, this.xSize = this.height, this.ySize = this.width) : (this.dx = this.width / (this.xmax - this.xmin), this.dy = this.height / (this.ymax - this.ymin), this.yStart = this.bottom, this.yEnd = this.top, this.xStart = this.left, this.xEnd = this.right, this.xSize = this.width, this.ySize = this.height), this.calc) ? this.calc() : void 0;\n    }, d.prototype.transY = function (a) {\n      return this.options.horizontal ? this.left + (a - this.ymin) * this.dy : this.bottom - (a - this.ymin) * this.dy;\n    }, d.prototype.transX = function (a) {\n      return 1 === this.data.length ? (this.xStart + this.xEnd) / 2 : this.xStart + (a - this.xmin) * this.dx;\n    }, d.prototype.redraw = function () {\n      return this.raphael.clear(), this._calc(), this.drawGrid(), this.drawGoals(), this.drawEvents(), this.draw ? this.draw() : void 0;\n    }, d.prototype.measureText = function (a, b) {\n      var c, d;\n      return null == b && (b = 0), d = this.raphael.text(100, 100, a).attr(\"font-size\", this.options.gridTextSize).attr(\"font-family\", this.options.gridTextFamily).attr(\"font-weight\", this.options.gridTextWeight).rotate(b), c = d.getBBox(), d.remove(), c;\n    }, d.prototype.yAxisFormat = function (a) {\n      return this.yLabelFormat(a, 0);\n    }, d.prototype.yLabelFormat = function (a, c) {\n      return \"function\" == typeof this.options.yLabelFormat ? this.options.yLabelFormat(a, c) : \"\" + this.options.preUnits + b.commas(a) + this.options.postUnits;\n    }, d.prototype.getYAxisLabelX = function () {\n      return this.left - this.options.padding / 2;\n    }, d.prototype.drawGrid = function () {\n      var a, b, c, d, e, f, g, h, i;\n\n      if (this.options.grid !== !1 || (f = this.options.axes) === !0 || \"both\" === f || \"y\" === f) {\n        for (a = this.options.horizontal ? this.getXAxisLabelY() : this.getYAxisLabelX(), g = this.grid, i = [], d = 0, e = g.length; e > d; d++) {\n          b = g[d], c = this.transY(b), ((h = this.options.axes) === !0 || \"both\" === h || \"y\" === h) && (this.options.horizontal ? this.drawXAxisLabel(c, a, this.yAxisFormat(b)) : this.drawYAxisLabel(a, c, this.yAxisFormat(b))), this.options.grid ? (c = Math.floor(c) + .5, i.push(this.options.horizontal ? this.drawGridLine(\"M\" + c + \",\" + this.xStart + \"V\" + this.xEnd) : this.drawGridLine(\"M\" + this.xStart + \",\" + c + \"H\" + this.xEnd))) : i.push(void 0);\n        }\n\n        return i;\n      }\n    }, d.prototype.drawGoals = function () {\n      var a, b, c, d, e, f, g;\n\n      for (f = this.options.goals, g = [], c = d = 0, e = f.length; e > d; c = ++d) {\n        b = f[c], a = this.options.goalLineColors[c % this.options.goalLineColors.length], g.push(this.drawGoal(b, a));\n      }\n\n      return g;\n    }, d.prototype.drawEvents = function () {\n      var a, b, c, d, e, f, g;\n\n      for (f = this.events, g = [], c = d = 0, e = f.length; e > d; c = ++d) {\n        b = f[c], a = this.options.eventLineColors[c % this.options.eventLineColors.length], g.push(this.drawEvent(b, a));\n      }\n\n      return g;\n    }, d.prototype.drawGoal = function (a, b) {\n      var c, d;\n      return d = Math.floor(this.transY(a)) + .5, c = this.options.horizontal ? \"M\" + d + \",\" + this.xStart + \"V\" + this.xEnd : \"M\" + this.xStart + \",\" + d + \"H\" + this.xEnd, this.raphael.path(c).attr(\"stroke\", b).attr(\"stroke-width\", this.options.goalStrokeWidth);\n    }, d.prototype.drawEvent = function (a, b) {\n      var c, d, e, f;\n      return a instanceof Array ? (c = a[0], e = a[1], c = Math.floor(this.transX(c)) + .5, e = Math.floor(this.transX(e)) + .5, this.options.horizontal ? this.raphael.rect(this.yStart, c, this.yEnd - this.yStart, e - c).attr({\n        fill: b,\n        stroke: !1\n      }).toBack() : this.raphael.rect(c, this.yEnd, e - c, this.yStart - this.yEnd).attr({\n        fill: b,\n        stroke: !1\n      }).toBack()) : (f = Math.floor(this.transX(a)) + .5, d = this.options.horizontal ? \"M\" + this.yStart + \",\" + f + \"H\" + this.yEnd : \"M\" + f + \",\" + this.yStart + \"V\" + this.yEnd, this.raphael.path(d).attr(\"stroke\", b).attr(\"stroke-width\", this.options.eventStrokeWidth));\n    }, d.prototype.drawYAxisLabel = function (a, b, c) {\n      return this.raphael.text(a, b, c).attr(\"font-size\", this.options.gridTextSize).attr(\"font-family\", this.options.gridTextFamily).attr(\"font-weight\", this.options.gridTextWeight).attr(\"fill\", this.options.gridTextColor).attr(\"text-anchor\", \"end\");\n    }, d.prototype.drawGridLine = function (a) {\n      return this.raphael.path(a).attr(\"stroke\", this.options.gridLineColor).attr(\"stroke-width\", this.options.gridStrokeWidth);\n    }, d.prototype.startRange = function (a) {\n      return this.hover.hide(), this.selectFrom = a, this.selectionRect.attr({\n        x: a,\n        width: 0\n      }).show();\n    }, d.prototype.endRange = function (a) {\n      var b, c;\n      return this.selectFrom ? (c = Math.min(this.selectFrom, a), b = Math.max(this.selectFrom, a), this.options.rangeSelect.call(this.el, {\n        start: this.data[this.hitTest(c)].x,\n        end: this.data[this.hitTest(b)].x\n      }), this.selectFrom = null) : void 0;\n    }, d.prototype.resizeHandler = function () {\n      return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw();\n    }, d.prototype.hasToShow = function (a) {\n      return this.options.shown === !0 || this.options.shown[a] === !0;\n    }, d;\n  }(b.EventEmitter), b.parseDate = function (a) {\n    var b, c, d, e, f, g, h, i, j, k, l;\n    return \"number\" == typeof a ? a : (c = a.match(/^(\\d+) Q(\\d)$/), e = a.match(/^(\\d+)-(\\d+)$/), f = a.match(/^(\\d+)-(\\d+)-(\\d+)$/), h = a.match(/^(\\d+) W(\\d+)$/), i = a.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+)(Z|([+-])(\\d\\d):?(\\d\\d))?$/), j = a.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+):(\\d+(\\.\\d+)?)(Z|([+-])(\\d\\d):?(\\d\\d))?$/), c ? new Date(parseInt(c[1], 10), 3 * parseInt(c[2], 10) - 1, 1).getTime() : e ? new Date(parseInt(e[1], 10), parseInt(e[2], 10) - 1, 1).getTime() : f ? new Date(parseInt(f[1], 10), parseInt(f[2], 10) - 1, parseInt(f[3], 10)).getTime() : h ? (k = new Date(parseInt(h[1], 10), 0, 1), 4 !== k.getDay() && k.setMonth(0, 1 + (4 - k.getDay() + 7) % 7), k.getTime() + 6048e5 * parseInt(h[2], 10)) : i ? i[6] ? (g = 0, \"Z\" !== i[6] && (g = 60 * parseInt(i[8], 10) + parseInt(i[9], 10), \"+\" === i[7] && (g = 0 - g)), Date.UTC(parseInt(i[1], 10), parseInt(i[2], 10) - 1, parseInt(i[3], 10), parseInt(i[4], 10), parseInt(i[5], 10) + g)) : new Date(parseInt(i[1], 10), parseInt(i[2], 10) - 1, parseInt(i[3], 10), parseInt(i[4], 10), parseInt(i[5], 10)).getTime() : j ? (l = parseFloat(j[6]), b = Math.floor(l), d = Math.round(1e3 * (l - b)), j[8] ? (g = 0, \"Z\" !== j[8] && (g = 60 * parseInt(j[10], 10) + parseInt(j[11], 10), \"+\" === j[9] && (g = 0 - g)), Date.UTC(parseInt(j[1], 10), parseInt(j[2], 10) - 1, parseInt(j[3], 10), parseInt(j[4], 10), parseInt(j[5], 10) + g, b, d)) : new Date(parseInt(j[1], 10), parseInt(j[2], 10) - 1, parseInt(j[3], 10), parseInt(j[4], 10), parseInt(j[5], 10), b, d).getTime()) : new Date(parseInt(a, 10), 0, 1).getTime());\n  }, b.Hover = function () {\n    function c(c) {\n      null == c && (c = {}), this.options = a.extend({}, b.Hover.defaults, c), this.el = a(\"<div class='\" + this.options[\"class\"] + \"'></div>\"), this.el.hide(), this.options.parent.append(this.el);\n    }\n\n    return c.defaults = {\n      \"class\": \"morris-hover morris-default-style\"\n    }, c.prototype.update = function (a, b, c, d) {\n      return a ? (this.html(a), this.show(), this.moveTo(b, c, d)) : this.hide();\n    }, c.prototype.html = function (a) {\n      return this.el.html(a);\n    }, c.prototype.moveTo = function (a, b, c) {\n      var d, e, f, g, h, i;\n      return h = this.options.parent.innerWidth(), g = this.options.parent.innerHeight(), e = this.el.outerWidth(), d = this.el.outerHeight(), f = Math.min(Math.max(0, a - e / 2), h - e), null != b ? c === !0 ? (i = b - d / 2, 0 > i && (i = 0)) : (i = b - d - 10, 0 > i && (i = b + 10, i + d > g && (i = g / 2 - d / 2))) : i = g / 2 - d / 2, this.el.css({\n        left: f + \"px\",\n        top: parseInt(i) + \"px\"\n      });\n    }, c.prototype.show = function () {\n      return this.el.show();\n    }, c.prototype.hide = function () {\n      return this.el.hide();\n    }, c;\n  }(), b.Line = function (c) {\n    function d(a) {\n      return this.hilight = f(this.hilight, this), this.onHoverOut = f(this.onHoverOut, this), this.onHoverMove = f(this.onHoverMove, this), this.onGridClick = f(this.onGridClick, this), this instanceof b.Line ? void d.__super__.constructor.call(this, a) : new b.Line(a);\n    }\n\n    return h(d, c), d.prototype.init = function () {\n      return \"always\" !== this.options.hideHover ? (this.hover = new b.Hover({\n        parent: this.el\n      }), this.on(\"hovermove\", this.onHoverMove), this.on(\"hoverout\", this.onHoverOut), this.on(\"gridclick\", this.onGridClick)) : void 0;\n    }, d.prototype.defaults = {\n      lineWidth: 3,\n      pointSize: 4,\n      lineColors: [\"#0b62a4\", \"#7A92A3\", \"#4da74d\", \"#afd8f8\", \"#edc240\", \"#cb4b4b\", \"#9440ed\"],\n      pointStrokeWidths: [1],\n      pointStrokeColors: [\"#ffffff\"],\n      pointFillColors: [],\n      smooth: !0,\n      shown: !0,\n      xLabels: \"auto\",\n      xLabelFormat: null,\n      xLabelMargin: 24,\n      hideHover: !1,\n      trendLine: !1,\n      trendLineWidth: 2,\n      trendLineColors: [\"#689bc3\", \"#a2b3bf\", \"#64b764\"]\n    }, d.prototype.calc = function () {\n      return this.calcPoints(), this.generatePaths();\n    }, d.prototype.calcPoints = function () {\n      var a, b, c, d, e, f;\n\n      for (e = this.data, f = [], c = 0, d = e.length; d > c; c++) {\n        a = e[c], a._x = this.transX(a.x), a._y = function () {\n          var c, d, e, f;\n\n          for (e = a.y, f = [], c = 0, d = e.length; d > c; c++) {\n            b = e[c], f.push(null != b ? this.transY(b) : b);\n          }\n\n          return f;\n        }.call(this), f.push(a._ymax = Math.min.apply(Math, [this.bottom].concat(function () {\n          var c, d, e, f;\n\n          for (e = a._y, f = [], c = 0, d = e.length; d > c; c++) {\n            b = e[c], null != b && f.push(b);\n          }\n\n          return f;\n        }())));\n      }\n\n      return f;\n    }, d.prototype.hitTest = function (a) {\n      var b, c, d, e, f;\n      if (0 === this.data.length) return null;\n\n      for (f = this.data.slice(1), b = d = 0, e = f.length; e > d && (c = f[b], !(a < (c._x + this.data[b]._x) / 2)); b = ++d) {\n        ;\n      }\n\n      return b;\n    }, d.prototype.onGridClick = function (a, b) {\n      var c;\n      return c = this.hitTest(a), this.fire(\"click\", c, this.data[c].src, a, b);\n    }, d.prototype.onHoverMove = function (a) {\n      var b;\n      return b = this.hitTest(a), this.displayHoverForRow(b);\n    }, d.prototype.onHoverOut = function () {\n      return this.options.hideHover !== !1 ? this.displayHoverForRow(null) : void 0;\n    }, d.prototype.displayHoverForRow = function (a) {\n      var b;\n      return null != a ? ((b = this.hover).update.apply(b, this.hoverContentForRow(a)), this.hilight(a)) : (this.hover.hide(), this.hilight());\n    }, d.prototype.hoverContentForRow = function (b) {\n      var c, d, e, f, g, h, i;\n\n      for (e = this.data[b], c = a(\"<div class='morris-hover-row-label'>\").text(e.label), c = c.prop(\"outerHTML\"), i = e.y, d = g = 0, h = i.length; h > g; d = ++g) {\n        f = i[d], this.options.labels[d] !== !1 && (c += \"<div class='morris-hover-point' style='color: \" + this.colorFor(e, d, \"label\") + \"'>\\n  \" + this.options.labels[d] + \":\\n  \" + this.yLabelFormat(f, d) + \"\\n</div>\");\n      }\n\n      return \"function\" == typeof this.options.hoverCallback && (c = this.options.hoverCallback(b, this.options, c, e.src)), [c, e._x, e._ymax];\n    }, d.prototype.generatePaths = function () {\n      var a, c, d, e;\n      return this.paths = function () {\n        var f, g, h, j;\n\n        for (j = [], c = f = 0, g = this.options.ykeys.length; g >= 0 ? g > f : f > g; c = g >= 0 ? ++f : --f) {\n          e = \"boolean\" == typeof this.options.smooth ? this.options.smooth : (h = this.options.ykeys[c], i.call(this.options.smooth, h) >= 0), a = function () {\n            var a, b, e, f;\n\n            for (e = this.data, f = [], a = 0, b = e.length; b > a; a++) {\n              d = e[a], void 0 !== d._y[c] && f.push({\n                x: d._x,\n                y: d._y[c]\n              });\n            }\n\n            return f;\n          }.call(this), j.push(a.length > 1 ? b.Line.createPath(a, e, this.bottom) : null);\n        }\n\n        return j;\n      }.call(this);\n    }, d.prototype.draw = function () {\n      var a;\n      return ((a = this.options.axes) === !0 || \"both\" === a || \"x\" === a) && this.drawXAxis(), this.drawSeries(), this.options.hideHover === !1 ? this.displayHoverForRow(this.data.length - 1) : void 0;\n    }, d.prototype.drawXAxis = function () {\n      var a,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l = this;\n\n      for (h = this.bottom + this.options.padding / 2, f = null, e = null, a = function a(_a, b) {\n        var c, d, g, i, j;\n        return c = l.drawXAxisLabel(l.transX(b), h, _a), j = c.getBBox(), c.transform(\"r\" + -l.options.xLabelAngle), d = c.getBBox(), c.transform(\"t0,\" + d.height / 2 + \"...\"), 0 !== l.options.xLabelAngle && (i = -.5 * j.width * Math.cos(l.options.xLabelAngle * Math.PI / 180), c.transform(\"t\" + i + \",0...\")), d = c.getBBox(), (null == f || f >= d.x + d.width || null != e && e >= d.x) && d.x >= 0 && d.x + d.width < l.el.width() ? (0 !== l.options.xLabelAngle && (g = 1.25 * l.options.gridTextSize / Math.sin(l.options.xLabelAngle * Math.PI / 180), e = d.x - g), f = d.x - l.options.xLabelMargin) : c.remove();\n      }, d = this.options.parseTime ? 1 === this.data.length && \"auto\" === this.options.xLabels ? [[this.data[0].label, this.data[0].x]] : b.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat) : function () {\n        var a, b, c, d;\n\n        for (c = this.data, d = [], a = 0, b = c.length; b > a; a++) {\n          g = c[a], d.push([g.label, g.x]);\n        }\n\n        return d;\n      }.call(this), d.reverse(), k = [], i = 0, j = d.length; j > i; i++) {\n        c = d[i], k.push(a(c[0], c[1]));\n      }\n\n      return k;\n    }, d.prototype.drawSeries = function () {\n      var a, b, c, d, e, f;\n\n      for (this.seriesPoints = [], a = b = d = this.options.ykeys.length - 1; 0 >= d ? 0 >= b : b >= 0; a = 0 >= d ? ++b : --b) {\n        this.hasToShow(a) && ((this.options.trendLine !== !1 && this.options.trendLine === !0 || this.options.trendLine[a] === !0) && this._drawTrendLine(a), this._drawLineFor(a));\n      }\n\n      for (f = [], a = c = e = this.options.ykeys.length - 1; 0 >= e ? 0 >= c : c >= 0; a = 0 >= e ? ++c : --c) {\n        f.push(this.hasToShow(a) ? this._drawPointFor(a) : void 0);\n      }\n\n      return f;\n    }, d.prototype._drawPointFor = function (a) {\n      var b, c, d, e, f, g;\n\n      for (this.seriesPoints[a] = [], f = this.data, g = [], d = 0, e = f.length; e > d; d++) {\n        c = f[d], b = null, null != c._y[a] && (b = this.drawLinePoint(c._x, c._y[a], this.colorFor(c, a, \"point\"), a)), g.push(this.seriesPoints[a].push(b));\n      }\n\n      return g;\n    }, d.prototype._drawLineFor = function (a) {\n      var b;\n      return b = this.paths[a], null !== b ? this.drawLinePath(b, this.colorFor(null, a, \"line\"), a) : void 0;\n    }, d.prototype._drawTrendLine = function (a) {\n      var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q;\n\n      for (h = 0, k = 0, i = 0, j = 0, f = 0, q = this.data, o = 0, p = q.length; p > o; o++) {\n        l = q[o], m = l.x, n = l.y[a], void 0 !== n && (f += 1, h += m, k += n, i += m * m, j += m * n);\n      }\n\n      return c = (f * j - h * k) / (f * i - h * h), d = k / f - c * h / f, e = [{}, {}], e[0].x = this.transX(this.data[0].x), e[0].y = this.transY(this.data[0].x * c + d), e[1].x = this.transX(this.data[this.data.length - 1].x), e[1].y = this.transY(this.data[this.data.length - 1].x * c + d), g = b.Line.createPath(e, !1, this.bottom), g = this.raphael.path(g).attr(\"stroke\", this.colorFor(null, a, \"trendLine\")).attr(\"stroke-width\", this.options.trendLineWidth);\n    }, d.createPath = function (a, c, d) {\n      var e, f, g, h, i, j, k, l, m, n, o, p, q, r;\n\n      for (k = \"\", c && (g = b.Line.gradients(a)), l = {\n        y: null\n      }, h = q = 0, r = a.length; r > q; h = ++q) {\n        e = a[h], null != e.y && (null != l.y ? c ? (f = g[h], j = g[h - 1], i = (e.x - l.x) / 4, m = l.x + i, o = Math.min(d, l.y + i * j), n = e.x - i, p = Math.min(d, e.y - i * f), k += \"C\" + m + \",\" + o + \",\" + n + \",\" + p + \",\" + e.x + \",\" + e.y) : k += \"L\" + e.x + \",\" + e.y : c && null == g[h] || (k += \"M\" + e.x + \",\" + e.y)), l = e;\n      }\n\n      return k;\n    }, d.gradients = function (a) {\n      var b, c, d, e, f, g, h, i;\n\n      for (c = function c(a, b) {\n        return (a.y - b.y) / (a.x - b.x);\n      }, i = [], d = g = 0, h = a.length; h > g; d = ++g) {\n        b = a[d], null != b.y ? (e = a[d + 1] || {\n          y: null\n        }, f = a[d - 1] || {\n          y: null\n        }, i.push(null != f.y && null != e.y ? c(f, e) : null != f.y ? c(f, b) : null != e.y ? c(b, e) : null)) : i.push(null);\n      }\n\n      return i;\n    }, d.prototype.hilight = function (a) {\n      var b, c, d, e, f;\n      if (null !== this.prevHilight && this.prevHilight !== a) for (b = c = 0, e = this.seriesPoints.length - 1; e >= 0 ? e >= c : c >= e; b = e >= 0 ? ++c : --c) {\n        this.seriesPoints[b][this.prevHilight] && this.seriesPoints[b][this.prevHilight].animate(this.pointShrinkSeries(b));\n      }\n      if (null !== a && this.prevHilight !== a) for (b = d = 0, f = this.seriesPoints.length - 1; f >= 0 ? f >= d : d >= f; b = f >= 0 ? ++d : --d) {\n        this.seriesPoints[b][a] && this.seriesPoints[b][a].animate(this.pointGrowSeries(b));\n      }\n      return this.prevHilight = a;\n    }, d.prototype.colorFor = function (a, b, c) {\n      return \"function\" == typeof this.options.lineColors ? this.options.lineColors.call(this, a, b, c) : \"point\" === c ? this.options.pointFillColors[b % this.options.pointFillColors.length] || this.options.lineColors[b % this.options.lineColors.length] : \"line\" === c ? this.options.lineColors[b % this.options.lineColors.length] : this.options.trendLineColors[b % this.options.trendLineColors.length];\n    }, d.prototype.drawXAxisLabel = function (a, b, c) {\n      return this.raphael.text(a, b, c).attr(\"font-size\", this.options.gridTextSize).attr(\"font-family\", this.options.gridTextFamily).attr(\"font-weight\", this.options.gridTextWeight).attr(\"fill\", this.options.gridTextColor);\n    }, d.prototype.drawLinePath = function (a, b, c) {\n      return this.raphael.path(a).attr(\"stroke\", b).attr(\"stroke-width\", this.lineWidthForSeries(c));\n    }, d.prototype.drawLinePoint = function (a, b, c, d) {\n      return this.raphael.circle(a, b, this.pointSizeForSeries(d)).attr(\"fill\", c).attr(\"stroke-width\", this.pointStrokeWidthForSeries(d)).attr(\"stroke\", this.pointStrokeColorForSeries(d));\n    }, d.prototype.pointStrokeWidthForSeries = function (a) {\n      return this.options.pointStrokeWidths[a % this.options.pointStrokeWidths.length];\n    }, d.prototype.pointStrokeColorForSeries = function (a) {\n      return this.options.pointStrokeColors[a % this.options.pointStrokeColors.length];\n    }, d.prototype.lineWidthForSeries = function (a) {\n      return this.options.lineWidth instanceof Array ? this.options.lineWidth[a % this.options.lineWidth.length] : this.options.lineWidth;\n    }, d.prototype.pointSizeForSeries = function (a) {\n      return this.options.pointSize instanceof Array ? this.options.pointSize[a % this.options.pointSize.length] : this.options.pointSize;\n    }, d.prototype.pointGrowSeries = function (a) {\n      return 0 !== this.pointSizeForSeries(a) ? Raphael.animation({\n        r: this.pointSizeForSeries(a) + 3\n      }, 25, \"linear\") : void 0;\n    }, d.prototype.pointShrinkSeries = function (a) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(a)\n      }, 25, \"linear\");\n    }, d;\n  }(b.Grid), b.labelSeries = function (c, d, e, f, g) {\n    var h, i, j, k, l, m, n, o, p, q, r;\n    if (j = 200 * (d - c) / e, i = new Date(c), n = b.LABEL_SPECS[f], void 0 === n) for (r = b.AUTO_LABEL_ORDER, p = 0, q = r.length; q > p; p++) {\n      if (k = r[p], m = b.LABEL_SPECS[k], j >= m.span) {\n        n = m;\n        break;\n      }\n    }\n\n    for (void 0 === n && (n = b.LABEL_SPECS.second), g && (n = a.extend({}, n, {\n      fmt: g\n    })), h = n.start(i), l = []; (o = h.getTime()) <= d;) {\n      o >= c && l.push([n.fmt(h), o]), n.incr(h);\n    }\n\n    return l;\n  }, c = function c(a) {\n    return {\n      span: 60 * a * 1e3,\n      start: function start(a) {\n        return new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours());\n      },\n      fmt: function fmt(a) {\n        return \"\" + b.pad2(a.getHours()) + \":\" + b.pad2(a.getMinutes());\n      },\n      incr: function incr(b) {\n        return b.setUTCMinutes(b.getUTCMinutes() + a);\n      }\n    };\n  }, d = function d(a) {\n    return {\n      span: 1e3 * a,\n      start: function start(a) {\n        return new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes());\n      },\n      fmt: function fmt(a) {\n        return \"\" + b.pad2(a.getHours()) + \":\" + b.pad2(a.getMinutes()) + \":\" + b.pad2(a.getSeconds());\n      },\n      incr: function incr(b) {\n        return b.setUTCSeconds(b.getUTCSeconds() + a);\n      }\n    };\n  }, b.LABEL_SPECS = {\n    decade: {\n      span: 1728e8,\n      start: function start(a) {\n        return new Date(a.getFullYear() - a.getFullYear() % 10, 0, 1);\n      },\n      fmt: function fmt(a) {\n        return \"\" + a.getFullYear();\n      },\n      incr: function incr(a) {\n        return a.setFullYear(a.getFullYear() + 10);\n      }\n    },\n    year: {\n      span: 1728e7,\n      start: function start(a) {\n        return new Date(a.getFullYear(), 0, 1);\n      },\n      fmt: function fmt(a) {\n        return \"\" + a.getFullYear();\n      },\n      incr: function incr(a) {\n        return a.setFullYear(a.getFullYear() + 1);\n      }\n    },\n    month: {\n      span: 24192e5,\n      start: function start(a) {\n        return new Date(a.getFullYear(), a.getMonth(), 1);\n      },\n      fmt: function fmt(a) {\n        return \"\" + a.getFullYear() + \"-\" + b.pad2(a.getMonth() + 1);\n      },\n      incr: function incr(a) {\n        return a.setMonth(a.getMonth() + 1);\n      }\n    },\n    week: {\n      span: 6048e5,\n      start: function start(a) {\n        return new Date(a.getFullYear(), a.getMonth(), a.getDate());\n      },\n      fmt: function fmt(a) {\n        return \"\" + a.getFullYear() + \"-\" + b.pad2(a.getMonth() + 1) + \"-\" + b.pad2(a.getDate());\n      },\n      incr: function incr(a) {\n        return a.setDate(a.getDate() + 7);\n      }\n    },\n    day: {\n      span: 864e5,\n      start: function start(a) {\n        return new Date(a.getFullYear(), a.getMonth(), a.getDate());\n      },\n      fmt: function fmt(a) {\n        return \"\" + a.getFullYear() + \"-\" + b.pad2(a.getMonth() + 1) + \"-\" + b.pad2(a.getDate());\n      },\n      incr: function incr(a) {\n        return a.setDate(a.getDate() + 1);\n      }\n    },\n    hour: c(60),\n    \"30min\": c(30),\n    \"15min\": c(15),\n    \"10min\": c(10),\n    \"5min\": c(5),\n    minute: c(1),\n    \"30sec\": d(30),\n    \"15sec\": d(15),\n    \"10sec\": d(10),\n    \"5sec\": d(5),\n    second: d(1)\n  }, b.AUTO_LABEL_ORDER = [\"decade\", \"year\", \"month\", \"week\", \"day\", \"hour\", \"30min\", \"15min\", \"10min\", \"5min\", \"minute\", \"30sec\", \"15sec\", \"10sec\", \"5sec\", \"second\"], b.Area = function (c) {\n    function d(c) {\n      var f;\n      return this instanceof b.Area ? (f = a.extend({}, e, c), this.cumulative = !f.behaveLikeLine, \"auto\" === f.fillOpacity && (f.fillOpacity = f.behaveLikeLine ? .8 : 1), void d.__super__.constructor.call(this, f)) : new b.Area(c);\n    }\n\n    var e;\n    return h(d, c), e = {\n      fillOpacity: \"auto\",\n      behaveLikeLine: !1\n    }, d.prototype.calcPoints = function () {\n      var a, b, c, d, e, f, g;\n\n      for (f = this.data, g = [], d = 0, e = f.length; e > d; d++) {\n        a = f[d], a._x = this.transX(a.x), b = 0, a._y = function () {\n          var d, e, f, g;\n\n          for (f = a.y, g = [], d = 0, e = f.length; e > d; d++) {\n            c = f[d], this.options.behaveLikeLine ? g.push(this.transY(c)) : (b += c || 0, g.push(this.transY(b)));\n          }\n\n          return g;\n        }.call(this), g.push(a._ymax = Math.max.apply(Math, a._y));\n      }\n\n      return g;\n    }, d.prototype.drawSeries = function () {\n      var a, b, c, d, e, f, g, h;\n\n      for (this.seriesPoints = [], b = this.options.behaveLikeLine ? function () {\n        f = [];\n\n        for (var a = 0, b = this.options.ykeys.length - 1; b >= 0 ? b >= a : a >= b; b >= 0 ? a++ : a--) {\n          f.push(a);\n        }\n\n        return f;\n      }.apply(this) : function () {\n        g = [];\n\n        for (var a = e = this.options.ykeys.length - 1; 0 >= e ? 0 >= a : a >= 0; 0 >= e ? a++ : a--) {\n          g.push(a);\n        }\n\n        return g;\n      }.apply(this), h = [], c = 0, d = b.length; d > c; c++) {\n        a = b[c], this._drawFillFor(a), this._drawLineFor(a), h.push(this._drawPointFor(a));\n      }\n\n      return h;\n    }, d.prototype._drawFillFor = function (a) {\n      var b;\n      return b = this.paths[a], null !== b ? (b += \"L\" + this.transX(this.xmax) + \",\" + this.bottom + \"L\" + this.transX(this.xmin) + \",\" + this.bottom + \"Z\", this.drawFilledPath(b, this.fillForSeries(a))) : void 0;\n    }, d.prototype.fillForSeries = function (a) {\n      var b;\n      return b = Raphael.rgb2hsl(this.colorFor(this.data[a], a, \"line\")), Raphael.hsl(b.h, this.options.behaveLikeLine ? .9 * b.s : .75 * b.s, Math.min(.98, this.options.behaveLikeLine ? 1.2 * b.l : 1.25 * b.l));\n    }, d.prototype.drawFilledPath = function (a, b) {\n      return this.raphael.path(a).attr(\"fill\", b).attr(\"fill-opacity\", this.options.fillOpacity).attr(\"stroke\", \"none\");\n    }, d;\n  }(b.Line), b.Bar = function (c) {\n    function d(c) {\n      return this.onHoverOut = f(this.onHoverOut, this), this.onHoverMove = f(this.onHoverMove, this), this.onGridClick = f(this.onGridClick, this), this instanceof b.Bar ? void d.__super__.constructor.call(this, a.extend({}, c, {\n        parseTime: !1\n      })) : new b.Bar(c);\n    }\n\n    return h(d, c), d.prototype.init = function () {\n      return this.cumulative = this.options.stacked, \"always\" !== this.options.hideHover ? (this.hover = new b.Hover({\n        parent: this.el\n      }), this.on(\"hovermove\", this.onHoverMove), this.on(\"hoverout\", this.onHoverOut), this.on(\"gridclick\", this.onGridClick)) : void 0;\n    }, d.prototype.defaults = {\n      barSizeRatio: .75,\n      barGap: 3,\n      barColors: [\"#0b62a4\", \"#7a92a3\", \"#4da74d\", \"#afd8f8\", \"#edc240\", \"#cb4b4b\", \"#9440ed\"],\n      barOpacity: 1,\n      barRadius: [0, 0, 0, 0],\n      xLabelMargin: 50,\n      horizontal: !1,\n      shown: !0\n    }, d.prototype.calc = function () {\n      var a;\n      return this.calcBars(), this.options.hideHover === !1 ? (a = this.hover).update.apply(a, this.hoverContentForRow(this.data.length - 1)) : void 0;\n    }, d.prototype.calcBars = function () {\n      var a, b, c, d, e, f, g;\n\n      for (f = this.data, g = [], a = d = 0, e = f.length; e > d; a = ++d) {\n        b = f[a], b._x = this.xStart + this.xSize * (a + .5) / this.data.length, g.push(b._y = function () {\n          var a, d, e, f;\n\n          for (e = b.y, f = [], a = 0, d = e.length; d > a; a++) {\n            c = e[a], f.push(null != c ? this.transY(c) : null);\n          }\n\n          return f;\n        }.call(this));\n      }\n\n      return g;\n    }, d.prototype.draw = function () {\n      var a;\n      return ((a = this.options.axes) === !0 || \"both\" === a || \"x\" === a) && this.drawXAxis(), this.drawSeries();\n    }, d.prototype.drawXAxis = function () {\n      var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q;\n\n      for (b = this.options.horizontal ? this.getYAxisLabelX() : this.getXAxisLabelY(), j = null, i = null, q = [], c = o = 0, p = this.data.length; p >= 0 ? p > o : o > p; c = p >= 0 ? ++o : --o) {\n        k = this.data[this.data.length - 1 - c], d = this.options.horizontal ? this.drawYAxisLabel(b, k._x - .5 * this.options.gridTextSize, k.label) : this.drawXAxisLabel(k._x, b, k.label), a = this.options.horizontal ? 0 : this.options.xLabelAngle, n = d.getBBox(), d.transform(\"r\" + -a), e = d.getBBox(), d.transform(\"t0,\" + e.height / 2 + \"...\"), 0 !== a && (h = -.5 * n.width * Math.cos(a * Math.PI / 180), d.transform(\"t\" + h + \",0...\")), this.options.horizontal ? (m = e.y, l = e.height, g = this.el.height()) : (m = e.x, l = e.width, g = this.el.width()), (null == j || j >= m + l || null != i && i >= m) && m >= 0 && g > m + l ? (0 !== a && (f = 1.25 * this.options.gridTextSize / Math.sin(a * Math.PI / 180), i = m - f), q.push(this.options.horizontal ? j = m : j = m - this.options.xLabelMargin)) : q.push(d.remove());\n      }\n\n      return q;\n    }, d.prototype.getXAxisLabelY = function () {\n      return this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);\n    }, d.prototype.drawSeries = function () {\n      var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r;\n      if (c = this.xSize / this.options.data.length, this.options.stacked) i = 1;else for (i = 0, d = q = 0, r = this.options.ykeys.length - 1; r >= 0 ? r >= q : q >= r; d = r >= 0 ? ++q : --q) {\n        this.hasToShow(d) && (i += 1);\n      }\n      return a = (c * this.options.barSizeRatio - this.options.barGap * (i - 1)) / i, this.options.barSize && (a = Math.min(a, this.options.barSize)), m = c - a * i - this.options.barGap * (i - 1), h = m / 2, p = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null, this.bars = function () {\n        var d, i, m, q;\n\n        for (m = this.data, q = [], e = d = 0, i = m.length; i > d; e = ++d) {\n          j = m[e], f = 0, q.push(function () {\n            var d, i, m, q;\n\n            for (m = j._y, q = [], k = d = 0, i = m.length; i > d; k = ++d) {\n              o = m[k], this.hasToShow(k) && (null !== o ? (p ? (n = Math.min(o, p), b = Math.max(o, p)) : (n = o, b = this.bottom), g = this.xStart + e * c + h, this.options.stacked || (g += k * (a + this.options.barGap)), l = b - n, this.options.verticalGridCondition && this.options.verticalGridCondition(j.x) && (this.options.horizontal ? this.drawBar(this.yStart, this.xStart + e * c, this.ySize, c, this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius) : this.drawBar(this.xStart + e * c, this.yEnd, c, this.ySize, this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius)), this.options.stacked && (n -= f), this.options.horizontal ? (this.drawBar(n, g, l, a, this.colorFor(j, k, \"bar\"), this.options.barOpacity, this.options.barRadius), q.push(f -= l)) : (this.drawBar(g, n, a, l, this.colorFor(j, k, \"bar\"), this.options.barOpacity, this.options.barRadius), q.push(f += l))) : q.push(null));\n            }\n\n            return q;\n          }.call(this));\n        }\n\n        return q;\n      }.call(this);\n    }, d.prototype.colorFor = function (a, b, c) {\n      var d, e;\n      return \"function\" == typeof this.options.barColors ? (d = {\n        x: a.x,\n        y: a.y[b],\n        label: a.label\n      }, e = {\n        index: b,\n        key: this.options.ykeys[b],\n        label: this.options.labels[b]\n      }, this.options.barColors.call(this, d, e, c)) : this.options.barColors[b % this.options.barColors.length];\n    }, d.prototype.hitTest = function (a, b) {\n      var c;\n      return 0 === this.data.length ? null : (c = this.options.horizontal ? b : a, c = Math.max(Math.min(c, this.xEnd), this.xStart), Math.min(this.data.length - 1, Math.floor((c - this.xStart) / (this.xSize / this.data.length))));\n    }, d.prototype.onGridClick = function (a, b) {\n      var c;\n      return c = this.hitTest(a, b), this.fire(\"click\", c, this.data[c].src, a, b);\n    }, d.prototype.onHoverMove = function (a, b) {\n      var c, d;\n      return c = this.hitTest(a, b), (d = this.hover).update.apply(d, this.hoverContentForRow(c));\n    }, d.prototype.onHoverOut = function () {\n      return this.options.hideHover !== !1 ? this.hover.hide() : void 0;\n    }, d.prototype.hoverContentForRow = function (b) {\n      var c, d, e, f, g, h, i, j;\n\n      for (e = this.data[b], c = a(\"<div class='morris-hover-row-label'>\").text(e.label), c = c.prop(\"outerHTML\"), j = e.y, d = h = 0, i = j.length; i > h; d = ++h) {\n        g = j[d], this.options.labels[d] !== !1 && (c += \"<div class='morris-hover-point' style='color: \" + this.colorFor(e, d, \"label\") + \"'>\\n  \" + this.options.labels[d] + \":\\n  \" + this.yLabelFormat(g, d) + \"\\n</div>\");\n      }\n\n      return \"function\" == typeof this.options.hoverCallback && (c = this.options.hoverCallback(b, this.options, c, e.src)), this.options.horizontal ? (f = this.left + .5 * this.width, g = this.top + (b + .5) * this.height / this.data.length, [c, f, g, !0]) : (f = this.left + (b + .5) * this.width / this.data.length, [c, f]);\n    }, d.prototype.drawXAxisLabel = function (a, b, c) {\n      var d;\n      return d = this.raphael.text(a, b, c).attr(\"font-size\", this.options.gridTextSize).attr(\"font-family\", this.options.gridTextFamily).attr(\"font-weight\", this.options.gridTextWeight).attr(\"fill\", this.options.gridTextColor);\n    }, d.prototype.drawBar = function (a, b, c, d, e, f, g) {\n      var h, i;\n      return h = Math.max.apply(Math, g), i = 0 === h || h > d ? this.raphael.rect(a, b, c, d) : this.raphael.path(this.roundedRect(a, b, c, d, g)), i.attr(\"fill\", e).attr(\"fill-opacity\", f).attr(\"stroke\", \"none\");\n    }, d.prototype.roundedRect = function (a, b, c, d, e) {\n      return null == e && (e = [0, 0, 0, 0]), [\"M\", a, e[0] + b, \"Q\", a, b, a + e[0], b, \"L\", a + c - e[1], b, \"Q\", a + c, b, a + c, b + e[1], \"L\", a + c, b + d - e[2], \"Q\", a + c, b + d, a + c - e[2], b + d, \"L\", a + e[3], b + d, \"Q\", a, b + d, a, b + d - e[3], \"Z\"];\n    }, d;\n  }(b.Grid), b.Donut = function (c) {\n    function d(c) {\n      this.resizeHandler = f(this.resizeHandler, this), this.select = f(this.select, this), this.click = f(this.click, this);\n      var d = this;\n      if (!(this instanceof b.Donut)) return new b.Donut(c);\n      if (this.options = a.extend({}, this.defaults, c), this.el = a(\"string\" == typeof c.element ? document.getElementById(c.element) : c.element), null === this.el || 0 === this.el.length) throw new Error(\"Graph placeholder not found.\");\n      void 0 !== c.data && 0 !== c.data.length && (this.raphael = new Raphael(this.el[0]), this.options.resize && a(window).bind(\"resize\", function () {\n        return null != d.timeoutId && window.clearTimeout(d.timeoutId), d.timeoutId = window.setTimeout(d.resizeHandler, 100);\n      }), this.setData(c.data));\n    }\n\n    return h(d, c), d.prototype.defaults = {\n      colors: [\"#0B62A4\", \"#3980B5\", \"#679DC6\", \"#95BBD7\", \"#B0CCE1\", \"#095791\", \"#095085\", \"#083E67\", \"#052C48\", \"#042135\"],\n      backgroundColor: \"#FFFFFF\",\n      labelColor: \"#000000\",\n      formatter: b.commas,\n      resize: !1\n    }, d.prototype.redraw = function () {\n      var a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x;\n\n      for (this.raphael.clear(), c = this.el.width() / 2, d = this.el.height() / 2, n = (Math.min(c, d) - 10) / 3, l = 0, u = this.values, o = 0, r = u.length; r > o; o++) {\n        m = u[o], l += m;\n      }\n\n      for (i = 5 / (2 * n), a = 1.9999 * Math.PI - i * this.data.length, g = 0, f = 0, this.segments = [], v = this.values, e = p = 0, s = v.length; s > p; e = ++p) {\n        m = v[e], j = g + i + a * (m / l), k = new b.DonutSegment(c, d, 2 * n, n, g, j, this.data[e].color || this.options.colors[f % this.options.colors.length], this.options.backgroundColor, f, this.raphael), k.render(), this.segments.push(k), k.on(\"hover\", this.select), k.on(\"click\", this.click), g = j, f += 1;\n      }\n\n      for (this.text1 = this.drawEmptyDonutLabel(c, d - 10, this.options.labelColor, 15, 800), this.text2 = this.drawEmptyDonutLabel(c, d + 10, this.options.labelColor, 14), h = Math.max.apply(Math, this.values), f = 0, w = this.values, x = [], q = 0, t = w.length; t > q; q++) {\n        if (m = w[q], m === h) {\n          this.select(f);\n          break;\n        }\n\n        x.push(f += 1);\n      }\n\n      return x;\n    }, d.prototype.setData = function (a) {\n      var b;\n      return this.data = a, this.values = function () {\n        var a, c, d, e;\n\n        for (d = this.data, e = [], a = 0, c = d.length; c > a; a++) {\n          b = d[a], e.push(parseFloat(b.value));\n        }\n\n        return e;\n      }.call(this), this.redraw();\n    }, d.prototype.click = function (a) {\n      return this.fire(\"click\", a, this.data[a]);\n    }, d.prototype.select = function (a) {\n      var b, c, d, e, f, g;\n\n      for (g = this.segments, e = 0, f = g.length; f > e; e++) {\n        c = g[e], c.deselect();\n      }\n\n      return d = this.segments[a], d.select(), b = this.data[a], this.setLabels(b.label, this.options.formatter(b.value, b));\n    }, d.prototype.setLabels = function (a, b) {\n      var c, d, e, f, g, h, i, j;\n      return c = 2 * (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) / 3, f = 1.8 * c, e = c / 2, d = c / 3, this.text1.attr({\n        text: a,\n        transform: \"\"\n      }), g = this.text1.getBBox(), h = Math.min(f / g.width, e / g.height), this.text1.attr({\n        transform: \"S\" + h + \",\" + h + \",\" + (g.x + g.width / 2) + \",\" + (g.y + g.height)\n      }), this.text2.attr({\n        text: b,\n        transform: \"\"\n      }), i = this.text2.getBBox(), j = Math.min(f / i.width, d / i.height), this.text2.attr({\n        transform: \"S\" + j + \",\" + j + \",\" + (i.x + i.width / 2) + \",\" + i.y\n      });\n    }, d.prototype.drawEmptyDonutLabel = function (a, b, c, d, e) {\n      var f;\n      return f = this.raphael.text(a, b, \"\").attr(\"font-size\", d).attr(\"fill\", c), null != e && f.attr(\"font-weight\", e), f;\n    }, d.prototype.resizeHandler = function () {\n      return this.timeoutId = null, this.raphael.setSize(this.el.width(), this.el.height()), this.redraw();\n    }, d;\n  }(b.EventEmitter), b.DonutSegment = function (a) {\n    function b(a, b, c, d, e, g, h, i, j, k) {\n      this.cx = a, this.cy = b, this.inner = c, this.outer = d, this.color = h, this.backgroundColor = i, this.index = j, this.raphael = k, this.deselect = f(this.deselect, this), this.select = f(this.select, this), this.sin_p0 = Math.sin(e), this.cos_p0 = Math.cos(e), this.sin_p1 = Math.sin(g), this.cos_p1 = Math.cos(g), this.is_long = g - e > Math.PI ? 1 : 0, this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5), this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer), this.hilight = this.calcArc(this.inner);\n    }\n\n    return h(b, a), b.prototype.calcArcPoints = function (a) {\n      return [this.cx + a * this.sin_p0, this.cy + a * this.cos_p0, this.cx + a * this.sin_p1, this.cy + a * this.cos_p1];\n    }, b.prototype.calcSegment = function (a, b) {\n      var c, d, e, f, g, h, i, j, k, l;\n      return k = this.calcArcPoints(a), c = k[0], e = k[1], d = k[2], f = k[3], l = this.calcArcPoints(b), g = l[0], i = l[1], h = l[2], j = l[3], \"M\" + c + \",\" + e + (\"A\" + a + \",\" + a + \",0,\" + this.is_long + \",0,\" + d + \",\" + f) + (\"L\" + h + \",\" + j) + (\"A\" + b + \",\" + b + \",0,\" + this.is_long + \",1,\" + g + \",\" + i) + \"Z\";\n    }, b.prototype.calcArc = function (a) {\n      var b, c, d, e, f;\n      return f = this.calcArcPoints(a), b = f[0], d = f[1], c = f[2], e = f[3], \"M\" + b + \",\" + d + (\"A\" + a + \",\" + a + \",0,\" + this.is_long + \",0,\" + c + \",\" + e);\n    }, b.prototype.render = function () {\n      var a = this;\n      return this.arc = this.drawDonutArc(this.hilight, this.color), this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function () {\n        return a.fire(\"hover\", a.index);\n      }, function () {\n        return a.fire(\"click\", a.index);\n      });\n    }, b.prototype.drawDonutArc = function (a, b) {\n      return this.raphael.path(a).attr({\n        stroke: b,\n        \"stroke-width\": 2,\n        opacity: 0\n      });\n    }, b.prototype.drawDonutSegment = function (a, b, c, d, e) {\n      return this.raphael.path(a).attr({\n        fill: b,\n        stroke: c,\n        \"stroke-width\": 3\n      }).hover(d).click(e);\n    }, b.prototype.select = function () {\n      return this.selected ? void 0 : (this.seg.animate({\n        path: this.selectedPath\n      }, 150, \"<>\"), this.arc.animate({\n        opacity: 1\n      }, 150, \"<>\"), this.selected = !0);\n    }, b.prototype.deselect = function () {\n      return this.selected ? (this.seg.animate({\n        path: this.path\n      }, 150, \"<>\"), this.arc.animate({\n        opacity: 0\n      }, 150, \"<>\"), this.selected = !1) : void 0;\n    }, b;\n  }(b.EventEmitter);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}