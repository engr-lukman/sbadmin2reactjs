{"ast":null,"code":"var _classCallCheck = require(\"/opt/lampp/htdocs/Lukman/sbadmin2reactjs/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/Lukman/sbadmin2reactjs/node_modules/@babel/runtime/helpers/createClass\");\n\n(function () {\n  var helper = require(\"./helper\");\n\n  var Board = require(\"morrisboard\");\n\n  var Exception = require(\"./Exception\");\n\n  var Morris =\n  /*#__PURE__*/\n  function () {\n    \"use strict\";\n\n    function Morris(options) {\n      _classCallCheck(this, Morris);\n\n      var self = this;\n      options = options.fillDefaults({\n        board: {\n          rows: 3,\n          points: [false, true, false],\n          default: []\n        },\n        pieces: 9,\n        rules: true,\n        lastChangeset: null,\n        teams: []\n      }); // Initialize morris board for game controller\n\n      this.board = new Board(options.board.rows, options.board.points); // Try to fill the board with default teams if they are given\n\n      this.board.map = this.board.map.map(function (point, i) {\n        // If the current point has a related default team in default-object of options\n        if (options.board.default[i]) {\n          // set point's team to the default one\n          point.team = options.board.default[i];\n        } // Return point because we are working with map method\n\n\n        return point;\n      }); // Just wether rule validating is active (Boolean)\n\n      this.rules = options.rules; // By default, 'teams' is just an array conatining team names\n      // Fill each one up to a team object\n\n      this.teams = this.teams.map(function (teamName) {\n        // Try to get the current team object from option's teams objects\n        // Option's team objects are used to fill defaults\n        var defaultTeam = options.teams.objectFromKey(teamName, \"name\"); // Team object that will repleace the team name\n\n        var team = {\n          name: teamName,\n          // Fill up the given amount of pieces with own 'fill' prototype function of Array\n          pieces: new Array(options.pieces).fill(function (index) {\n            // Try to use properties from this piece within the defaultTeam given from options\n            // But if this does not exist, use an empty piece instead\n            return {\n              point: defaultTeam && \"pieces\" in defaultTeam && index in defaultTeam.pieces ? defaultTeam.pieces[index].point : null,\n              removed: defaultTeam && \"pieces\" in defaultTeam && index in defaultTeam.pieces ? defaultTeam.pieces[index].removed : false\n            };\n          }),\n\n          // Returns all active pieces within this team\n          // \"Active\" means pieces, that are just not removed yet\n          get activePieces() {\n            // 'removed' property of a piece is always 'false' if the piece is not removed\n            return this.pieces.filter(function (piece) {\n              return !piece.removed;\n            });\n          },\n\n          // Returns all pieces within this team that are on the board and moveable\n          get moveablePieces() {\n            // Filter for all pieces whose point property's type is number which excludes the 'null' value\n            return this.activePieces.filter(function (piece) {\n              return typeof piece.point === \"number\";\n            });\n          }\n\n        };\n        return team;\n      }); // Try to set an existing lastChangeset to the instance if one is given in options\n\n      this.__lastChangeset = options.lastChangeset || null;\n    } // Calculates the next team's name that is used to move\n\n\n    _createClass(Morris, [{\n      key: \"getPiece\",\n      // Get piece by position object\n      value: function getPiece(pos) {\n        var index = this.board.getPointIndex(pos.row, pos.position);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.teams[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var team = _step.value;\n            var relatedPiece = team.pieces.objectFromKey(index, \"point\");\n\n            if (relatedPiece) {\n              return relatedPiece;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } // Method to set a piece to a point and validate this movement with the rules\n\n    }, {\n      key: \"set\",\n      value: function set(options) {\n        var _this = this;\n\n        var sandbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        // Get the point object by using its position given from options\n        var targetPoint = this.board.getPoint(options.row, options.position); // Prototype the changeset\n\n        var changeset = {\n          success: false,\n          action: \"set\",\n          piece: null,\n          targetPoint: targetPoint\n        }; // Errors will be thrown by adding them to the changeset\n        // Anonymous function to use the return break\n\n        (function () {\n          // If the target point is invalid, throw an error\n          if (!targetPoint) {\n            changeset.error = new Exception(\"Point is invalid or does not exist\", 3, \"data\");\n            return;\n          } // Get team object from options \"team\" prooperty\n\n\n          var team = _this.teams.objectFromKey(options.team, \"name\"); // If this team is inavlid, throw an error\n\n\n          if (!team) {\n            changeset.error = new Exception(\"Team is invalid\", 0, \"data\");\n            return;\n          } // If the next team that is allowed to interact is not the team that is tried to set and rule validation is allowed\n\n\n          if (_this.rules && _this.nextTeam != options.team) {\n            changeset.error = new Exception(\"Team is not allowed to set\", 2, \"rule\");\n            return;\n          } // Get first piece that isn't setted yet\n\n\n          var piece = team.pieces.objectFromKey(null, \"point\"); // If there exist a piece that should be edited\n\n          if (piece) {\n            changeset.piece = piece; // Piece is valid\n            // If target point has no piece on it or if it has one, rule validation has to be disabled\n\n            if (!targetPoint.team || !_this.rules) {\n              // Movement is okay\n              // But change only something really if sandbox is d\n              if (!sandbox) {\n                // Set the piece on the board and return its index\n                var settedIndex = _this.board.set(options); // Set the related piece's point property to this index to relate the piece to the point on the board\n\n\n                piece.point = settedIndex;\n              }\n            } else {\n              changeset.error = new Exception(\"Point (target) is already used by piece.\", 4, \"rule\", {\n                targetPoint: targetPoint\n              });\n            }\n          } else {\n            changeset.error = new Exception(\"Team has no unused pieces anymore\", 1, \"data\");\n          }\n        })(); // If no error occured\n\n\n        if (!changeset.error) {\n          // Set success of the changeset to true\n          changeset.success = true; // If sandbox is not used, the successfull movement will be saved in the last changeset property\n\n          if (!sandbox) {\n            this.__lastChangeset = changeset;\n          }\n        } // Return changeset\n\n\n        return changeset;\n      }\n    }, {\n      key: \"move\",\n      value: function move(from, to) {\n        var _this2 = this;\n\n        var sandbox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // Get the indexes of the points we are working with\n        var fromIndex = this.board.getPointIndex(from.row, from.position);\n        var toIndex = this.board.getPointIndex(to.row, to.position); // Get the point objects\n\n        var startPoint = this.board.map[fromIndex];\n        var targetPoint = this.board.map[toIndex]; // Protoytpe changeset\n\n        var changeset = {\n          success: false,\n          action: \"move\",\n          piece: null,\n          startPoint: startPoint,\n          targetPoint: targetPoint\n        }; // Errors will be thrown by adding them to the changeset\n        // Anonymous function to use the return break\n\n        (function () {\n          // If start or target point is not valid, throw an error\n          if (!startPoint || !targetPoint) {\n            changeset.error = new Exception(\"Cannot move piece. Start point or target point is invalid or does not exist\", 3, \"data\");\n            return;\n          } // If the start point's team is false which means that the point has no piece on it\n          // And therefore, you can not move any piece from it to another point\n\n\n          if (!startPoint.team) {\n            changeset.error = new Exception(\"Cannot move piece from point. No piece on this point\", 4, \"data\");\n            return;\n          } // Get the piece standing on the start point\n\n\n          var piece = _this2.getPiece(from); // Refer this piece to the changeset\n\n\n          changeset.piece = piece; // Validate movement with rules\n\n          if (_this2.validateMovement(startPoint, targetPoint) || !_this2.rules) {\n            // If validating was successfully or rules are disabled, go on\n            if (!sandbox) {\n              _this2.board.move(fromIndex, toIndex);\n\n              piece.point = toIndex;\n            }\n          } else {\n            changeset.error = new Exception(\"Invalid movement. Cannot move piece over such a distance or this team is not allowed to move\", 5, \"rule\");\n          }\n        })();\n\n        if (!changeset.error) {\n          changeset.success = true;\n\n          if (!sandbox) {\n            this.__lastChangeset = changeset;\n          }\n        }\n\n        return changeset;\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(point) {\n        var sandbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var targetPoint = this.board.getPoint(point.row, point.position);\n        var startIndex = this.board.map.indexOf(targetPoint);\n        var piece = this.teams.objectFromKey(targetPoint.team, \"name\").pieces.objectFromKey(startIndex, \"point\");\n        var changeset = {\n          success: false,\n          action: \"remove\",\n          piece: piece,\n          // Define team explictily because the piece who was used to interact with is defintly not a piece of the team that is doing the removement\n          team: this.getTeam(this.__lastChangeset.piece),\n          targetPoint: targetPoint\n        };\n\n        if (targetPoint && typeof piece.point === \"number\") {\n          if (targetPoint.team === this.nextTeam && this.nextAction === \"remove\" && targetPoint.mills.length <= 0 || !this.rules) {\n            if (!sandbox) {\n              this.board.remove(startIndex);\n              piece.removed = true;\n              piece.point = undefined;\n            }\n          } else {\n            changeset.error = new Exception(\"Not allowed to remove pieces of this team\", 7, \"rule\");\n          }\n        } else {\n          changeset.error = new Exception(\"Piece or point is invalid or does not exist\", 3, \"data\");\n        }\n\n        if (!changeset.error) {\n          changeset.success = true;\n\n          if (!sandbox) {\n            this.__lastChangeset = changeset;\n          }\n        }\n\n        return changeset;\n      } // Method to validate a movement in general by using all the aspects of Nine Men's Morris rules\n\n    }, {\n      key: \"validateMovement\",\n      value: function validateMovement(from, to) {\n        // Get reference from point to related team\n        var teamRef = this.teams.objectFromKey(from.team, \"name\"); //console.log(teamRef.name, Board.isSurrounding(from, to), this.board.map.indexOf(from.surroundings.right));\n        // Check wether the related team has 3 or less active (unremoved) pieces (Jumping is allowed) or if not, the target point borders on the point directly\n\n        return (teamRef.activePieces.length <= 3 || Board.isSurrounding(from, to)) && this.nextTeam === from.team && !to.team;\n      }\n    }, {\n      key: \"getTeam\",\n      value: function getTeam(piece) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.teams[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var team = _step2.value;\n\n            if (team.pieces.includes(piece)) {\n              return team.name;\n            }\n          }\n          /*for (var team of this.teams) {\n            if (team.pieces.objectFromKey(piece.point, \"point\")) {\n              return team.name;\n            }\n          }*/\n\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getMoves\",\n      value: function getMoves() {\n        var self = this;\n        var movements = [];\n        var actions = {\n          set: function set() {\n            // Returns all empty points on the board which have no piece on it (team: false)\n            var emptyPoints = self.board.map.filter(function (point) {\n              return !point.team;\n            }); // Loop trough all possible target points\n\n            emptyPoints.forEach(function (point) {\n              // Assign setting options from point's position and the next team\n              var pointInfo = Object.assign({\n                team: self.nextTeam\n              }, point.position); // Set this point for the next team in sandbox mode (true)\n\n              var testSet = self.set(pointInfo, true); // Sandbox setting was successfull, add it to array\n\n              if (testSet.success) {\n                // Push an movement describing object to the array 'movements'\n                movements.push({\n                  action: \"set\",\n                  team: pointInfo.team,\n                  targetPoint: point\n                });\n              }\n            });\n          },\n          move: function move() {\n            var usedPoints = self.board.map.filter(function (point) {\n              return point.team;\n            }); // Loop trough all used points on the board and check wether the pieces on them can be moved to a different point\n\n            usedPoints.forEach(function (startPoint) {\n              // Loop trough the whole board now and check wether 'startPoint's piece can be moved to the current target point\n              self.board.map.forEach(function (targetPoint) {\n                // Validate a theoretically movement between these two points\n                if (self.validateMovement(startPoint, targetPoint)) {\n                  // Such a movement seems to be valid\n                  // Push a movement describing object to the array 'movements'\n                  movements.push({\n                    action: \"move\",\n                    startPoint: startPoint,\n                    targetPoint: targetPoint\n                  });\n                }\n              });\n            });\n          },\n          remove: function remove() {\n            var usedPoints = self.board.map.filter(function (point) {\n              return point.team;\n            }); // Loop trough all used points on the board and check wether the pieces on them can be moved to a different point\n\n            usedPoints.forEach(function (targetPoint) {\n              // Remove piece in sandbox mode and check the success\n              var removement = self.remove(targetPoint.position, true); // Wether the removement is allowed\n\n              if (removement.success) {\n                // Push a movement describing object to the array 'movements'\n                movements.push({\n                  action: \"remove\",\n                  targetPoint: targetPoint\n                });\n              }\n            });\n          }\n        };\n        actions[this.nextAction]();\n        return movements;\n      }\n    }, {\n      key: \"nextTeam\",\n      get: function get() {\n        // Check wether there exist a last changeset\n        if (this.__lastChangeset) {\n          // Get the team name of the last change normally directly from the piece\n          // Sometimes the chnageset contains a seperate 'team' property that is used if the piece that was used to interact with is not a part of the team that interacted\n          // This case is when a \"removement\" happened (A piece will always be removed by the contrary team)\n          var teamName = this.__lastChangeset.team || this.getTeam(this.__lastChangeset.piece);\n          var teamIndex = this.teams.indexOfKey(teamName, \"name\"); // Try to just use the \"next\" team in 'teams' array but if the current one is the last one, jump over to the first one\n\n          return teamIndex + 1 in this.teams ? this.teams[teamIndex + 1].name : this.teams[0].name;\n        } // No last changeset, return first team's name because this one is always starting the match\n\n\n        return this.teams[0].name;\n      } // Calculates the next action that should be performed\n\n    }, {\n      key: \"nextAction\",\n      get: function get() {\n        // Check wether there exist a last changeset\n        if (this.__lastChangeset) {\n          // Check wether the target point of the last changeset (last movement) is involved in at least one mill\n          // That means, that this mill was created with this movement (last changeset)\n          if (this.__lastChangeset.targetPoint.mills.length > 0) {\n            // Next action should be removed\n            // Please keep in mind that the \"nextTeam\" now is the contrary team of the team that created the mill. This may looks not correct but it is absolutely correct because we will remove the piece from this contrary team\n            return \"remove\";\n          }\n        } // The last changeset's target point seems not to be a part of a created mill which means that we will get the next action just by checking the current game's phase (0-2)\n\n\n        var phaseActions = [\"set\", \"move\", \"move\"]; // Return the action that is related to current pahse of the game\n\n        return phaseActions[this.phase];\n      } // Returns current pahse of the game\n\n    }, {\n      key: \"phase\",\n      get: function get() {\n        // Loop trough teams and check wether they have at least one unused piece (Phase 1)\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.teams[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var team = _step3.value;\n\n            // Returns the index of first piece object that's 'point' property is null of current team\n            // If this index is not -1, such a piece object exists and phause 1 is still active because there is a team that is allowed to 'set()'\n            if (team.pieces.indexOfKey(null, \"point\") > -1) {\n              // Return 0 to represent phase 1\n              return 0;\n            }\n          } // No piece found that's \"point\" property is null\n          // Phase 1 is completed, looking for phase 2 or 3 ...\n          // Loop trough teams to check wether they have three or less active (unremoved) pieces on board\n\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.teams[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var team = _step4.value;\n\n            // Filter the pieces array for a false in \"removed\" property\n            // If the returning array's length is three or less, phase 2 is completed and phase 3 is the current one\n            if (team.activePieces.length <= 3) {\n              // Return 2 to represent phase 3\n              return 2;\n            }\n          } // There exist no unused pieces but no team has three or less active pieces\n          // Return 1 to represent phase 2\n\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        return 1;\n      } // Returns wether the game is game over\n\n    }, {\n      key: \"gameOver\",\n      get: function get() {\n        // Loop trough all teams to check wether they have more than 0 active pieces\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this.teams[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var team = _step5.value;\n\n            // Check the current team for having no active pieces\n            if (team.activePieces.length <= 0) {\n              // Return true because obviously the game is over\n              return true;\n            }\n          } // Every team has at least one active piece\n          // Game is still running, return false\n\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        return false;\n      } // Returns wether the game is a draw\n\n    }, {\n      key: \"draw\",\n      get: function get() {\n        // Game has to not to be over and there should be no possible move\n        return !this.gameOver && this.getMoves().length <= 0;\n      }\n    }]);\n\n    return Morris;\n  }();\n\n  Morris.prototype.teams = [\"white\", \"black\"];\n\n  if (\"process\" in this) {\n    module.exports = Morris;\n  } else {\n    window.MorrisGame = Morris;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}