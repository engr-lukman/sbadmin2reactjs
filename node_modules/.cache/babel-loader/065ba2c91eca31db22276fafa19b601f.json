{"ast":null,"code":"/*! Responsive 1.0.6\n * 2014-2015 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     1.0.6\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014-2015 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (window, document, undefined) {\n  var factory = function factory($, DataTable) {\n    \"use strict\";\n    /**\n     * Responsive is a plug-in for the DataTables library that makes use of\n     * DataTables' ability to change the visibility of columns, changing the\n     * visibility of columns so the displayed columns fit into the table container.\n     * The end result is that complex tables will be dynamically adjusted to fit\n     * into the viewport, be it on a desktop, tablet or mobile browser.\n     *\n     * Responsive for DataTables has two modes of operation, which can used\n     * individually or combined:\n     *\n     * * Class name based control - columns assigned class names that match the\n     *   breakpoint logic can be shown / hidden as required for each breakpoint.\n     * * Automatic control - columns are automatically hidden when there is no\n     *   room left to display them. Columns removed from the right.\n     *\n     * In additional to column visibility control, Responsive also has built into\n     * options to use DataTables' child row display to show / hide the information\n     * from the table that has been hidden. There are also two modes of operation\n     * for this child row display:\n     *\n     * * Inline - when the control element that the user can use to show / hide\n     *   child rows is displayed inside the first column of the table.\n     * * Column - where a whole column is dedicated to be the show / hide control.\n     *\n     * Initialisation of Responsive is performed by:\n     *\n     * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n     *   Responsive will automatically be initialised with the default configuration\n     *   options when the DataTable is created.\n     * * Using the `responsive` option in the DataTables configuration options. This\n     *   can also be used to specify the configuration options, or simply set to\n     *   `true` to use the defaults.\n     *\n     *  @class\n     *  @param {object} settings DataTables settings object for the host table\n     *  @param {object} [opts] Configuration options\n     *  @requires jQuery 1.7+\n     *  @requires DataTables 1.10.1+\n     *\n     *  @example\n     *      $('#example').DataTable( {\n     *        responsive: true\n     *      } );\n     *    } );\n     */\n\n    var Responsive = function Responsive(settings, opts) {\n      // Sanity check that we are using DataTables 1.10 or newer\n      if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.1')) {\n        throw 'DataTables Responsive requires DataTables 1.10.1 or newer';\n      }\n\n      this.s = {\n        dt: new DataTable.Api(settings),\n        columns: []\n      }; // Check if responsive has already been initialised on this table\n\n      if (this.s.dt.settings()[0].responsive) {\n        return;\n      } // details is an object, but for simplicity the user can give it as a string\n\n\n      if (opts && typeof opts.details === 'string') {\n        opts.details = {\n          type: opts.details\n        };\n      }\n\n      this.c = $.extend(true, {}, Responsive.defaults, DataTable.defaults.responsive, opts);\n      settings.responsive = this;\n\n      this._constructor();\n    };\n\n    Responsive.prototype = {\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Constructor\n       */\n\n      /**\n       * Initialise the Responsive instance\n       *\n       * @private\n       */\n      _constructor: function _constructor() {\n        var that = this;\n        var dt = this.s.dt;\n        dt.settings()[0]._responsive = this; // Use DataTables' private throttle function to avoid processor thrashing\n\n        $(window).on('resize.dtr orientationchange.dtr', dt.settings()[0].oApi._fnThrottle(function () {\n          that._resize();\n        })); // Destroy event handler\n\n        dt.on('destroy.dtr', function () {\n          $(window).off('resize.dtr orientationchange.dtr draw.dtr');\n        }); // Reorder the breakpoints array here in case they have been added out\n        // of order\n\n        this.c.breakpoints.sort(function (a, b) {\n          return a.width < b.width ? 1 : a.width > b.width ? -1 : 0;\n        }); // Determine which columns are already hidden, and should therefore\n        // remain hidden. todo - should this be done? See thread 22677\n        //\n        // this.s.alwaysHidden = dt.columns(':hidden').indexes();\n\n        this._classLogic();\n\n        this._resizeAuto(); // Details handler\n\n\n        var details = this.c.details;\n\n        if (details.type) {\n          that._detailsInit();\n\n          this._detailsVis();\n\n          dt.on('column-visibility.dtr', function () {\n            that._detailsVis();\n          }); // Redraw the details box on each draw. This is used until\n          // DataTables implements a native `updated` event for rows\n\n          dt.on('draw.dtr', function () {\n            dt.rows({\n              page: 'current'\n            }).iterator('row', function (settings, idx) {\n              var row = dt.row(idx);\n\n              if (row.child.isShown()) {\n                var info = that.c.details.renderer(dt, idx);\n                row.child(info, 'child').show();\n              }\n            });\n          });\n          $(dt.table().node()).addClass('dtr-' + details.type);\n        } // First pass - draw the table for the current viewport size\n\n\n        this._resize();\n      },\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Private methods\n       */\n\n      /**\n       * Calculate the visibility for the columns in a table for a given\n       * breakpoint. The result is pre-determined based on the class logic if\n       * class names are used to control all columns, but the width of the table\n       * is also used if there are columns which are to be automatically shown\n       * and hidden.\n       *\n       * @param  {string} breakpoint Breakpoint name to use for the calculation\n       * @return {array} Array of boolean values initiating the visibility of each\n       *   column.\n       *  @private\n       */\n      _columnsVisiblity: function _columnsVisiblity(breakpoint) {\n        var dt = this.s.dt;\n        var columns = this.s.columns;\n        var i, ien; // Class logic - determine which columns are in this breakpoint based\n        // on the classes. If no class control (i.e. `auto`) then `-` is used\n        // to indicate this to the rest of the function\n\n        var display = $.map(columns, function (col) {\n          return col.auto && col.minWidth === null ? false : col.auto === true ? '-' : $.inArray(breakpoint, col.includeIn) !== -1;\n        }); // Auto column control - first pass: how much width is taken by the\n        // ones that must be included from the non-auto columns\n\n        var requiredWidth = 0;\n\n        for (i = 0, ien = display.length; i < ien; i++) {\n          if (display[i] === true) {\n            requiredWidth += columns[i].minWidth;\n          }\n        } // Second pass, use up any remaining width for other columns. For\n        // scrolling tables we need to subtract the width of the scrollbar. It\n        // may not be requires which makes this sub-optimal, but it would\n        // require another full redraw to make complete use of those extra few\n        // pixels\n\n\n        var scrolling = dt.settings()[0].oScroll;\n        var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;\n        var widthAvailable = dt.table().container().offsetWidth - bar;\n        var usedWidth = widthAvailable - requiredWidth; // Control column needs to always be included. This makes it sub-\n        // optimal in terms of using the available with, but to stop layout\n        // thrashing or overflow. Also we need to account for the control column\n        // width first so we know how much width is available for the other\n        // columns, since the control column might not be the first one shown\n\n        for (i = 0, ien = display.length; i < ien; i++) {\n          if (columns[i].control) {\n            usedWidth -= columns[i].minWidth;\n          }\n        } // Allow columns to be shown (counting from the left) until we run out\n        // of room\n\n\n        var empty = false;\n\n        for (i = 0, ien = display.length; i < ien; i++) {\n          if (display[i] === '-' && !columns[i].control) {\n            // Once we've found a column that won't fit we don't let any\n            // others display either, or columns might disappear in the\n            // middle of the table\n            if (empty || usedWidth - columns[i].minWidth < 0) {\n              empty = true;\n              display[i] = false;\n            } else {\n              display[i] = true;\n            }\n\n            usedWidth -= columns[i].minWidth;\n          }\n        } // Determine if the 'control' column should be shown (if there is one).\n        // This is the case when there is a hidden column (that is not the\n        // control column). The two loops look inefficient here, but they are\n        // trivial and will fly through. We need to know the outcome from the\n        // first , before the action in the second can be taken\n\n\n        var showControl = false;\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (!columns[i].control && !columns[i].never && !display[i]) {\n            showControl = true;\n            break;\n          }\n        }\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (columns[i].control) {\n            display[i] = showControl;\n          }\n        } // Finally we need to make sure that there is at least one column that\n        // is visible\n\n\n        if ($.inArray(true, display) === -1) {\n          display[0] = true;\n        }\n\n        return display;\n      },\n\n      /**\n       * Create the internal `columns` array with information about the columns\n       * for the table. This includes determining which breakpoints the column\n       * will appear in, based upon class names in the column, which makes up the\n       * vast majority of this method.\n       *\n       * @private\n       */\n      _classLogic: function _classLogic() {\n        var that = this;\n        var calc = {};\n        var breakpoints = this.c.breakpoints;\n        var columns = this.s.dt.columns().eq(0).map(function (i) {\n          var className = this.column(i).header().className;\n          return {\n            className: className,\n            includeIn: [],\n            auto: false,\n            control: false,\n            never: className.match(/\\bnever\\b/) ? true : false\n          };\n        }); // Simply add a breakpoint to `includeIn` array, ensuring that there are\n        // no duplicates\n\n        var add = function add(colIdx, name) {\n          var includeIn = columns[colIdx].includeIn;\n\n          if ($.inArray(name, includeIn) === -1) {\n            includeIn.push(name);\n          }\n        };\n\n        var column = function column(colIdx, name, operator, matched) {\n          var size, i, ien;\n\n          if (!operator) {\n            columns[colIdx].includeIn.push(name);\n          } else if (operator === 'max-') {\n            // Add this breakpoint and all smaller\n            size = that._find(name).width;\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width <= size) {\n                add(colIdx, breakpoints[i].name);\n              }\n            }\n          } else if (operator === 'min-') {\n            // Add this breakpoint and all larger\n            size = that._find(name).width;\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width >= size) {\n                add(colIdx, breakpoints[i].name);\n              }\n            }\n          } else if (operator === 'not-') {\n            // Add all but this breakpoint (xxx need extra information)\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].name.indexOf(matched) === -1) {\n                add(colIdx, breakpoints[i].name);\n              }\n            }\n          }\n        }; // Loop over each column and determine if it has a responsive control\n        // class\n\n\n        columns.each(function (col, i) {\n          var classNames = col.className.split(' ');\n          var hasClass = false; // Split the class name up so multiple rules can be applied if needed\n\n          for (var k = 0, ken = classNames.length; k < ken; k++) {\n            var className = $.trim(classNames[k]);\n\n            if (className === 'all') {\n              // Include in all\n              hasClass = true;\n              col.includeIn = $.map(breakpoints, function (a) {\n                return a.name;\n              });\n              return;\n            } else if (className === 'none' || className === 'never') {\n              // Include in none (default) and no auto\n              hasClass = true;\n              return;\n            } else if (className === 'control') {\n              // Special column that is only visible, when one of the other\n              // columns is hidden. This is used for the details control\n              hasClass = true;\n              col.control = true;\n              return;\n            }\n\n            $.each(breakpoints, function (j, breakpoint) {\n              // Does this column have a class that matches this breakpoint?\n              var brokenPoint = breakpoint.name.split('-');\n              var re = new RegExp('(min\\\\-|max\\\\-|not\\\\-)?(' + brokenPoint[0] + ')(\\\\-[_a-zA-Z0-9])?');\n              var match = className.match(re);\n\n              if (match) {\n                hasClass = true;\n\n                if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {\n                  // Class name matches breakpoint name fully\n                  column(i, breakpoint.name, match[1], match[2] + match[3]);\n                } else if (match[2] === brokenPoint[0] && !match[3]) {\n                  // Class name matched primary breakpoint name with no qualifier\n                  column(i, breakpoint.name, match[1], match[2]);\n                }\n              }\n            });\n          } // If there was no control class, then automatic sizing is used\n\n\n          if (!hasClass) {\n            col.auto = true;\n          }\n        });\n        this.s.columns = columns;\n      },\n\n      /**\n       * Initialisation for the details handler\n       *\n       * @private\n       */\n      _detailsInit: function _detailsInit() {\n        var that = this;\n        var dt = this.s.dt;\n        var details = this.c.details; // The inline type always uses the first child as the target\n\n        if (details.type === 'inline') {\n          details.target = 'td:first-child';\n        } // type.target can be a string jQuery selector or a column index\n\n\n        var target = details.target;\n        var selector = typeof target === 'string' ? target : 'td'; // Click handler to show / hide the details rows when they are available\n\n        $(dt.table().body()).on('click', selector, function (e) {\n          // If the table is not collapsed (i.e. there is no hidden columns)\n          // then take no action\n          if (!$(dt.table().node()).hasClass('collapsed')) {\n            return;\n          } // Check that the row is actually a DataTable's controlled node\n\n\n          if (!dt.row($(this).closest('tr')).length) {\n            return;\n          } // For column index, we determine if we should act or not in the\n          // handler - otherwise it is already okay\n\n\n          if (typeof target === 'number') {\n            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target;\n\n            if (dt.cell(this).index().column !== targetIdx) {\n              return;\n            }\n          } // $().closest() includes itself in its check\n\n\n          var row = dt.row($(this).closest('tr'));\n\n          if (row.child.isShown()) {\n            row.child(false);\n            $(row.node()).removeClass('parent');\n          } else {\n            var info = that.c.details.renderer(dt, row[0]);\n            row.child(info, 'child').show();\n            $(row.node()).addClass('parent');\n          }\n        });\n      },\n\n      /**\n       * Update the child rows in the table whenever the column visibility changes\n       *\n       * @private\n       */\n      _detailsVis: function _detailsVis() {\n        var that = this;\n        var dt = this.s.dt; // Find how many columns are hidden\n\n        var hiddenColumns = dt.columns().indexes().filter(function (idx) {\n          var col = dt.column(idx);\n\n          if (col.visible()) {\n            return null;\n          } // Only counts as hidden if it doesn't have the `never` class\n\n\n          return $(col.header()).hasClass('never') ? null : idx;\n        });\n        var haveHidden = true;\n\n        if (hiddenColumns.length === 0 || hiddenColumns.length === 1 && this.s.columns[hiddenColumns[0]].control) {\n          haveHidden = false;\n        }\n\n        if (haveHidden) {\n          // Show all existing child rows\n          dt.rows({\n            page: 'current'\n          }).eq(0).each(function (idx) {\n            var row = dt.row(idx);\n\n            if (row.child()) {\n              var info = that.c.details.renderer(dt, row[0]); // The renderer can return false to have no child row\n\n              if (info === false) {\n                row.child.hide();\n              } else {\n                row.child(info, 'child').show();\n              }\n            }\n          });\n        } else {\n          // Hide all existing child rows\n          dt.rows({\n            page: 'current'\n          }).eq(0).each(function (idx) {\n            dt.row(idx).child.hide();\n          });\n        }\n      },\n\n      /**\n       * Find a breakpoint object from a name\n       * @param  {string} name Breakpoint name to find\n       * @return {object}      Breakpoint description object\n       */\n      _find: function _find(name) {\n        var breakpoints = this.c.breakpoints;\n\n        for (var i = 0, ien = breakpoints.length; i < ien; i++) {\n          if (breakpoints[i].name === name) {\n            return breakpoints[i];\n          }\n        }\n      },\n\n      /**\n       * Alter the table display for a resized viewport. This involves first\n       * determining what breakpoint the window currently is in, getting the\n       * column visibilities to apply and then setting them.\n       *\n       * @private\n       */\n      _resize: function _resize() {\n        var dt = this.s.dt;\n        var width = $(window).width();\n        var breakpoints = this.c.breakpoints;\n        var breakpoint = breakpoints[0].name;\n        var columns = this.s.columns;\n        var i, ien; // Determine what breakpoint we are currently at\n\n        for (i = breakpoints.length - 1; i >= 0; i--) {\n          if (width <= breakpoints[i].width) {\n            breakpoint = breakpoints[i].name;\n            break;\n          }\n        } // Show the columns for that break point\n\n\n        var columnsVis = this._columnsVisiblity(breakpoint); // Set the class before the column visibility is changed so event\n        // listeners know what the state is. Need to determine if there are\n        // any columns that are not visible but can be shown\n\n\n        var collapsedClass = false;\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (columnsVis[i] === false && !columns[i].never) {\n            collapsedClass = true;\n            break;\n          }\n        }\n\n        $(dt.table().node()).toggleClass('collapsed', collapsedClass);\n        dt.columns().eq(0).each(function (colIdx, i) {\n          dt.column(colIdx).visible(columnsVis[i]);\n        });\n      },\n\n      /**\n       * Determine the width of each column in the table so the auto column hiding\n       * has that information to work with. This method is never going to be 100%\n       * perfect since column widths can change slightly per page, but without\n       * seriously compromising performance this is quite effective.\n       *\n       * @private\n       */\n      _resizeAuto: function _resizeAuto() {\n        var dt = this.s.dt;\n        var columns = this.s.columns; // Are we allowed to do auto sizing?\n\n        if (!this.c.auto) {\n          return;\n        } // Are there any columns that actually need auto-sizing, or do they all\n        // have classes defined\n\n\n        if ($.inArray(true, $.map(columns, function (c) {\n          return c.auto;\n        })) === -1) {\n          return;\n        } // Clone the table with the current data in it\n\n\n        var tableWidth = dt.table().node().offsetWidth;\n        var columnWidths = dt.columns;\n        var clonedTable = dt.table().node().cloneNode(false);\n        var clonedHeader = $(dt.table().header().cloneNode(false)).appendTo(clonedTable);\n        var clonedBody = $(dt.table().body().cloneNode(false)).appendTo(clonedTable);\n        $(dt.table().footer()).clone(false).appendTo(clonedTable); // This is a bit slow, but we need to get a clone of each row that\n        // includes all columns. As such, try to do this as little as possible.\n\n        dt.rows({\n          page: 'current'\n        }).indexes().flatten().each(function (idx) {\n          var clone = dt.row(idx).node().cloneNode(true);\n\n          if (dt.columns(':hidden').flatten().length) {\n            $(clone).append(dt.cells(idx, ':hidden').nodes().to$().clone());\n          }\n\n          $(clone).appendTo(clonedBody);\n        });\n        var cells = dt.columns().header().to$().clone(false);\n        $('<tr/>').append(cells).appendTo(clonedHeader); // In the inline case extra padding is applied to the first column to\n        // give space for the show / hide icon. We need to use this in the\n        // calculation\n\n        if (this.c.details.type === 'inline') {\n          $(clonedTable).addClass('dtr-inline collapsed');\n        }\n\n        var inserted = $('<div/>').css({\n          width: 1,\n          height: 1,\n          overflow: 'hidden'\n        }).append(clonedTable); // Remove columns which are not to be included\n\n        inserted.find('th.never, td.never').remove();\n        inserted.insertBefore(dt.table().node()); // The cloned header now contains the smallest that each column can be\n\n        dt.columns().eq(0).each(function (idx) {\n          columns[idx].minWidth = cells[idx].offsetWidth || 0;\n        });\n        inserted.remove();\n      }\n    };\n    /**\n     * List of default breakpoints. Each item in the array is an object with two\n     * properties:\n     *\n     * * `name` - the breakpoint name.\n     * * `width` - the breakpoint width\n     *\n     * @name Responsive.breakpoints\n     * @static\n     */\n\n    Responsive.breakpoints = [{\n      name: 'desktop',\n      width: Infinity\n    }, {\n      name: 'tablet-l',\n      width: 1024\n    }, {\n      name: 'tablet-p',\n      width: 768\n    }, {\n      name: 'mobile-l',\n      width: 480\n    }, {\n      name: 'mobile-p',\n      width: 320\n    }];\n    /**\n     * Responsive default settings for initialisation\n     *\n     * @namespace\n     * @name Responsive.defaults\n     * @static\n     */\n\n    Responsive.defaults = {\n      /**\n       * List of breakpoints for the instance. Note that this means that each\n       * instance can have its own breakpoints. Additionally, the breakpoints\n       * cannot be changed once an instance has been creased.\n       *\n       * @type {Array}\n       * @default Takes the value of `Responsive.breakpoints`\n       */\n      breakpoints: Responsive.breakpoints,\n\n      /**\n       * Enable / disable auto hiding calculations. It can help to increase\n       * performance slightly if you disable this option, but all columns would\n       * need to have breakpoint classes assigned to them\n       *\n       * @type {Boolean}\n       * @default  `true`\n       */\n      auto: true,\n\n      /**\n       * Details control. If given as a string value, the `type` property of the\n       * default object is set to that value, and the defaults used for the rest\n       * of the object - this is for ease of implementation.\n       *\n       * The object consists of the following properties:\n       *\n       * * `renderer` - function that is called for display of the child row data.\n       *   The default function will show the data from the hidden columns\n       * * `target` - Used as the selector for what objects to attach the child\n       *   open / close to\n       * * `type` - `false` to disable the details display, `inline` or `column`\n       *   for the two control types\n       *\n       * @type {Object|string}\n       */\n      details: {\n        renderer: function renderer(api, rowIdx) {\n          var data = api.cells(rowIdx, ':hidden').eq(0).map(function (cell) {\n            var header = $(api.column(cell.column).header());\n            var idx = api.cell(cell).index();\n\n            if (header.hasClass('control') || header.hasClass('never')) {\n              return '';\n            } // Use a non-public DT API method to render the data for display\n            // This needs to be updated when DT adds a suitable method for\n            // this type of data retrieval\n\n\n            var dtPrivate = api.settings()[0];\n\n            var cellData = dtPrivate.oApi._fnGetCellData(dtPrivate, idx.row, idx.column, 'display');\n\n            var title = header.text();\n\n            if (title) {\n              title = title + ':';\n            }\n\n            return '<li data-dtr-index=\"' + idx.column + '\">' + '<span class=\"dtr-title\">' + title + '</span> ' + '<span class=\"dtr-data\">' + cellData + '</span>' + '</li>';\n          }).toArray().join('');\n          return data ? $('<ul data-dtr-index=\"' + rowIdx + '\"/>').append(data) : false;\n        },\n        target: 0,\n        type: 'inline'\n      }\n    };\n    /*\n     * API\n     */\n\n    var Api = $.fn.dataTable.Api; // Doesn't do anything - work around for a bug in DT... Not documented\n\n    Api.register('responsive()', function () {\n      return this;\n    });\n    Api.register('responsive.index()', function (li) {\n      li = $(li);\n      return {\n        column: li.data('dtr-index'),\n        row: li.parent().data('dtr-index')\n      };\n    });\n    Api.register('responsive.rebuild()', function () {\n      return this.iterator('table', function (ctx) {\n        if (ctx._responsive) {\n          ctx._responsive._classLogic();\n        }\n      });\n    });\n    Api.register('responsive.recalc()', function () {\n      return this.iterator('table', function (ctx) {\n        if (ctx._responsive) {\n          ctx._responsive._resizeAuto();\n\n          ctx._responsive._resize();\n        }\n      });\n    });\n    /**\n     * Version information\n     *\n     * @name Responsive.version\n     * @static\n     */\n\n    Responsive.version = '1.0.6';\n    $.fn.dataTable.Responsive = Responsive;\n    $.fn.DataTable.Responsive = Responsive; // Attach a listener to the document which listens for DataTables initialisation\n    // events so we can automatically initialise\n\n    $(document).on('init.dt.dtr', function (e, settings, json) {\n      if (e.namespace !== 'dt') {\n        return;\n      }\n\n      if ($(settings.nTable).hasClass('responsive') || $(settings.nTable).hasClass('dt-responsive') || settings.oInit.responsive || DataTable.defaults.responsive) {\n        var init = settings.oInit.responsive;\n\n        if (init !== false) {\n          new Responsive(settings, $.isPlainObject(init) ? init : {});\n        }\n      }\n    });\n    return Responsive;\n  }; // /factory\n  // Define as an AMD module if possible\n\n\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery', 'datatables'], factory);\n  } else if (typeof exports === 'object') {\n    // Node/CommonJS\n    factory(require('jquery'), require('datatables'));\n  } else if (jQuery && !jQuery.fn.dataTable.Responsive) {\n    // Otherwise simply initialise as normal, stopping multiple evaluation\n    factory(jQuery, jQuery.fn.dataTable);\n  }\n})(window, document);","map":null,"metadata":{},"sourceType":"script"}