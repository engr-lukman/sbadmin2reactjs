{"ast":null,"code":"/* Pretty handling of time axes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\nAPI.txt for details.\n\n*/\n(function ($) {\n  var options = {\n    xaxis: {\n      timezone: null,\n      // \"browser\" for local to the client or timezone for timezone-js\n      timeformat: null,\n      // format string to use\n      twelveHourClock: false,\n      // 12 or 24 time in time mode\n      monthNames: null // list of names of months\n\n    }\n  }; // round to nearby lower multiple of base\n\n  function floorInBase(n, base) {\n    return base * Math.floor(n / base);\n  } // Returns a string with the date d formatted according to fmt.\n  // A subset of the Open Group's strftime format is supported.\n\n\n  function formatDate(d, fmt, monthNames, dayNames) {\n    if (typeof d.strftime == \"function\") {\n      return d.strftime(fmt);\n    }\n\n    var leftPad = function leftPad(n, pad) {\n      n = \"\" + n;\n      pad = \"\" + (pad == null ? \"0\" : pad);\n      return n.length == 1 ? pad + n : n;\n    };\n\n    var r = [];\n    var escape = false;\n    var hours = d.getHours();\n    var isAM = hours < 12;\n\n    if (monthNames == null) {\n      monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    }\n\n    if (dayNames == null) {\n      dayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    }\n\n    var hours12;\n\n    if (hours > 12) {\n      hours12 = hours - 12;\n    } else if (hours == 0) {\n      hours12 = 12;\n    } else {\n      hours12 = hours;\n    }\n\n    for (var i = 0; i < fmt.length; ++i) {\n      var c = fmt.charAt(i);\n\n      if (escape) {\n        switch (c) {\n          case 'a':\n            c = \"\" + dayNames[d.getDay()];\n            break;\n\n          case 'b':\n            c = \"\" + monthNames[d.getMonth()];\n            break;\n\n          case 'd':\n            c = leftPad(d.getDate());\n            break;\n\n          case 'e':\n            c = leftPad(d.getDate(), \" \");\n            break;\n\n          case 'h': // For back-compat with 0.7; remove in 1.0\n\n          case 'H':\n            c = leftPad(hours);\n            break;\n\n          case 'I':\n            c = leftPad(hours12);\n            break;\n\n          case 'l':\n            c = leftPad(hours12, \" \");\n            break;\n\n          case 'm':\n            c = leftPad(d.getMonth() + 1);\n            break;\n\n          case 'M':\n            c = leftPad(d.getMinutes());\n            break;\n          // quarters not in Open Group's strftime specification\n\n          case 'q':\n            c = \"\" + (Math.floor(d.getMonth() / 3) + 1);\n            break;\n\n          case 'S':\n            c = leftPad(d.getSeconds());\n            break;\n\n          case 'y':\n            c = leftPad(d.getFullYear() % 100);\n            break;\n\n          case 'Y':\n            c = \"\" + d.getFullYear();\n            break;\n\n          case 'p':\n            c = isAM ? \"\" + \"am\" : \"\" + \"pm\";\n            break;\n\n          case 'P':\n            c = isAM ? \"\" + \"AM\" : \"\" + \"PM\";\n            break;\n\n          case 'w':\n            c = \"\" + d.getDay();\n            break;\n        }\n\n        r.push(c);\n        escape = false;\n      } else {\n        if (c == \"%\") {\n          escape = true;\n        } else {\n          r.push(c);\n        }\n      }\n    }\n\n    return r.join(\"\");\n  } // To have a consistent view of time-based data independent of which time\n  // zone the client happens to be in we need a date-like object independent\n  // of time zones.  This is done through a wrapper that only calls the UTC\n  // versions of the accessor methods.\n\n\n  function makeUtcWrapper(d) {\n    function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n      sourceObj[sourceMethod] = function () {\n        return targetObj[targetMethod].apply(targetObj, arguments);\n      };\n    }\n\n    ;\n    var utc = {\n      date: d\n    }; // support strftime, if found\n\n    if (d.strftime != undefined) {\n      addProxyMethod(utc, \"strftime\", d, \"strftime\");\n    }\n\n    addProxyMethod(utc, \"getTime\", d, \"getTime\");\n    addProxyMethod(utc, \"setTime\", d, \"setTime\");\n    var props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\n\n    for (var p = 0; p < props.length; p++) {\n      addProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n      addProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n    }\n\n    return utc;\n  }\n\n  ; // select time zone strategy.  This returns a date-like object tied to the\n  // desired timezone\n\n  function dateGenerator(ts, opts) {\n    if (opts.timezone == \"browser\") {\n      return new Date(ts);\n    } else if (!opts.timezone || opts.timezone == \"utc\") {\n      return makeUtcWrapper(new Date(ts));\n    } else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\n      var d = new timezoneJS.Date(); // timezone-js is fickle, so be sure to set the time zone before\n      // setting the time.\n\n      d.setTimezone(opts.timezone);\n      d.setTime(ts);\n      return d;\n    } else {\n      return makeUtcWrapper(new Date(ts));\n    }\n  } // map of app. size of time units in milliseconds\n\n\n  var timeUnitSize = {\n    \"second\": 1000,\n    \"minute\": 60 * 1000,\n    \"hour\": 60 * 60 * 1000,\n    \"day\": 24 * 60 * 60 * 1000,\n    \"month\": 30 * 24 * 60 * 60 * 1000,\n    \"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\n    \"year\": 365.2425 * 24 * 60 * 60 * 1000\n  }; // the allowed tick sizes, after 1 year we use\n  // an integer algorithm\n\n  var baseSpec = [[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"], [30, \"second\"], [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"], [30, \"minute\"], [1, \"hour\"], [2, \"hour\"], [4, \"hour\"], [8, \"hour\"], [12, \"hour\"], [1, \"day\"], [2, \"day\"], [3, \"day\"], [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"], [2, \"month\"]]; // we don't know which variant(s) we'll need yet, but generating both is\n  // cheap\n\n  var specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"], [1, \"year\"]]);\n  var specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"], [1, \"year\"]]);\n\n  function init(plot) {\n    plot.hooks.processOptions.push(function (plot, options) {\n      $.each(plot.getAxes(), function (axisName, axis) {\n        var opts = axis.options;\n\n        if (opts.mode == \"time\") {\n          axis.tickGenerator = function (axis) {\n            var ticks = [];\n            var d = dateGenerator(axis.min, opts);\n            var minSize = 0; // make quarter use a possibility if quarters are\n            // mentioned in either of these options\n\n            var spec = opts.tickSize && opts.tickSize[1] === \"quarter\" || opts.minTickSize && opts.minTickSize[1] === \"quarter\" ? specQuarters : specMonths;\n\n            if (opts.minTickSize != null) {\n              if (typeof opts.tickSize == \"number\") {\n                minSize = opts.tickSize;\n              } else {\n                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n              }\n            }\n\n            for (var i = 0; i < spec.length - 1; ++i) {\n              if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]] + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2 && spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n                break;\n              }\n            }\n\n            var size = spec[i][0];\n            var unit = spec[i][1]; // special-case the possibility of several years\n\n            if (unit == \"year\") {\n              // if given a minTickSize in years, just use it,\n              // ensuring that it's an integer\n              if (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\n                size = Math.floor(opts.minTickSize[0]);\n              } else {\n                var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n                var norm = axis.delta / timeUnitSize.year / magn;\n\n                if (norm < 1.5) {\n                  size = 1;\n                } else if (norm < 3) {\n                  size = 2;\n                } else if (norm < 7.5) {\n                  size = 5;\n                } else {\n                  size = 10;\n                }\n\n                size *= magn;\n              } // minimum size for years is 1\n\n\n              if (size < 1) {\n                size = 1;\n              }\n            }\n\n            axis.tickSize = opts.tickSize || [size, unit];\n            var tickSize = axis.tickSize[0];\n            unit = axis.tickSize[1];\n            var step = tickSize * timeUnitSize[unit];\n\n            if (unit == \"second\") {\n              d.setSeconds(floorInBase(d.getSeconds(), tickSize));\n            } else if (unit == \"minute\") {\n              d.setMinutes(floorInBase(d.getMinutes(), tickSize));\n            } else if (unit == \"hour\") {\n              d.setHours(floorInBase(d.getHours(), tickSize));\n            } else if (unit == \"month\") {\n              d.setMonth(floorInBase(d.getMonth(), tickSize));\n            } else if (unit == \"quarter\") {\n              d.setMonth(3 * floorInBase(d.getMonth() / 3, tickSize));\n            } else if (unit == \"year\") {\n              d.setFullYear(floorInBase(d.getFullYear(), tickSize));\n            } // reset smaller components\n\n\n            d.setMilliseconds(0);\n\n            if (step >= timeUnitSize.minute) {\n              d.setSeconds(0);\n            }\n\n            if (step >= timeUnitSize.hour) {\n              d.setMinutes(0);\n            }\n\n            if (step >= timeUnitSize.day) {\n              d.setHours(0);\n            }\n\n            if (step >= timeUnitSize.day * 4) {\n              d.setDate(1);\n            }\n\n            if (step >= timeUnitSize.month * 2) {\n              d.setMonth(floorInBase(d.getMonth(), 3));\n            }\n\n            if (step >= timeUnitSize.quarter * 2) {\n              d.setMonth(floorInBase(d.getMonth(), 6));\n            }\n\n            if (step >= timeUnitSize.year) {\n              d.setMonth(0);\n            }\n\n            var carry = 0;\n            var v = Number.NaN;\n            var prev;\n\n            do {\n              prev = v;\n              v = d.getTime();\n              ticks.push(v);\n\n              if (unit == \"month\" || unit == \"quarter\") {\n                if (tickSize < 1) {\n                  // a bit complicated - we'll divide the\n                  // month/quarter up but we need to take\n                  // care of fractions so we don't end up in\n                  // the middle of a day\n                  d.setDate(1);\n                  var start = d.getTime();\n                  d.setMonth(d.getMonth() + (unit == \"quarter\" ? 3 : 1));\n                  var end = d.getTime();\n                  d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\n                  carry = d.getHours();\n                  d.setHours(0);\n                } else {\n                  d.setMonth(d.getMonth() + tickSize * (unit == \"quarter\" ? 3 : 1));\n                }\n              } else if (unit == \"year\") {\n                d.setFullYear(d.getFullYear() + tickSize);\n              } else {\n                d.setTime(v + step);\n              }\n            } while (v < axis.max && v != prev);\n\n            return ticks;\n          };\n\n          axis.tickFormatter = function (v, axis) {\n            var d = dateGenerator(v, axis.options); // first check global format\n\n            if (opts.timeformat != null) {\n              return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\n            } // possibly use quarters if quarters are mentioned in\n            // any of these places\n\n\n            var useQuarters = axis.options.tickSize && axis.options.tickSize[1] == \"quarter\" || axis.options.minTickSize && axis.options.minTickSize[1] == \"quarter\";\n            var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n            var span = axis.max - axis.min;\n            var suffix = opts.twelveHourClock ? \" %p\" : \"\";\n            var hourCode = opts.twelveHourClock ? \"%I\" : \"%H\";\n            var fmt;\n\n            if (t < timeUnitSize.minute) {\n              fmt = hourCode + \":%M:%S\" + suffix;\n            } else if (t < timeUnitSize.day) {\n              if (span < 2 * timeUnitSize.day) {\n                fmt = hourCode + \":%M\" + suffix;\n              } else {\n                fmt = \"%b %d \" + hourCode + \":%M\" + suffix;\n              }\n            } else if (t < timeUnitSize.month) {\n              fmt = \"%b %d\";\n            } else if (useQuarters && t < timeUnitSize.quarter || !useQuarters && t < timeUnitSize.year) {\n              if (span < timeUnitSize.year) {\n                fmt = \"%b\";\n              } else {\n                fmt = \"%b %Y\";\n              }\n            } else if (useQuarters && t < timeUnitSize.year) {\n              if (span < timeUnitSize.year) {\n                fmt = \"Q%q\";\n              } else {\n                fmt = \"Q%q %Y\";\n              }\n            } else {\n              fmt = \"%Y\";\n            }\n\n            var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\n            return rt;\n          };\n        }\n      });\n    });\n  }\n\n  $.plot.plugins.push({\n    init: init,\n    options: options,\n    name: 'time',\n    version: '1.0'\n  }); // Time-axis support used to be in Flot core, which exposed the\n  // formatDate function on the plot object.  Various plugins depend\n  // on the function, so we need to re-expose it here.\n\n  $.plot.formatDate = formatDate;\n  $.plot.dateGenerator = dateGenerator;\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}