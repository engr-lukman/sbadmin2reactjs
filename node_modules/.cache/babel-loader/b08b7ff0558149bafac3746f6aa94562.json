{"ast":null,"code":"/* Flot plugin for rendering pie charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes that each series has a single data value, and that each\nvalue is a positive integer or zero.  Negative numbers don't make sense for a\npie chart, and have unpredictable results.  The values do NOT need to be\npassed in as percentages; the plugin will calculate the total and per-slice\npercentages internally.\n\n* Created by Brian Medendorp\n\n* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\n\nThe plugin supports these options:\n\n\tseries: {\n\t\tpie: {\n\t\t\tshow: true/false\n\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\n\t\t\tinnerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\n\t\t\tstartAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\n\t\t\ttilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\n\t\t\toffset: {\n\t\t\t\ttop: integer value to move the pie up or down\n\t\t\t\tleft: integer value to move the pie left or right, or 'auto'\n\t\t\t},\n\t\t\tstroke: {\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\n\t\t\t\twidth: integer pixel width of the stroke\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\tshow: true/false, or 'auto'\n\t\t\t\tformatter:  a user-defined function that modifies the text/style of the label text\n\t\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length\n\t\t\t\tbackground: {\n\t\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\n\t\t\t\t\topacity: 0-1\n\t\t\t\t},\n\t\t\t\tthreshold: 0-1 for the percentage value at which to hide labels (if they're too small)\n\t\t\t},\n\t\t\tcombine: {\n\t\t\t\tthreshold: 0-1 for the percentage value at which to combine slices (if they're too small)\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\n\t\t\t\tlabel: any text value of what the combined slice should be labeled\n\t\t\t}\n\t\t\thighlight: {\n\t\t\t\topacity: 0-1\n\t\t\t}\n\t\t}\n\t}\n\nMore detail and specific examples can be found in the included HTML file.\n\n*/\n(function ($) {\n  // Maximum redraw attempts when fitting labels within the plot\n  var REDRAW_ATTEMPTS = 10; // Factor by which to shrink the pie when fitting labels within the plot\n\n  var REDRAW_SHRINK = 0.95;\n\n  function init(plot) {\n    var canvas = null,\n        target = null,\n        options = null,\n        maxRadius = null,\n        centerLeft = null,\n        centerTop = null,\n        processed = false,\n        ctx = null; // interactive variables\n\n    var highlights = []; // add hook to determine if pie plugin in enabled, and then perform necessary operations\n\n    plot.hooks.processOptions.push(function (plot, options) {\n      if (options.series.pie.show) {\n        options.grid.show = false; // set labels.show\n\n        if (options.series.pie.label.show == \"auto\") {\n          if (options.legend.show) {\n            options.series.pie.label.show = false;\n          } else {\n            options.series.pie.label.show = true;\n          }\n        } // set radius\n\n\n        if (options.series.pie.radius == \"auto\") {\n          if (options.series.pie.label.show) {\n            options.series.pie.radius = 3 / 4;\n          } else {\n            options.series.pie.radius = 1;\n          }\n        } // ensure sane tilt\n\n\n        if (options.series.pie.tilt > 1) {\n          options.series.pie.tilt = 1;\n        } else if (options.series.pie.tilt < 0) {\n          options.series.pie.tilt = 0;\n        }\n      }\n    });\n    plot.hooks.bindEvents.push(function (plot, eventHolder) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        if (options.grid.hoverable) {\n          eventHolder.unbind(\"mousemove\").mousemove(onMouseMove);\n        }\n\n        if (options.grid.clickable) {\n          eventHolder.unbind(\"click\").click(onClick);\n        }\n      }\n    });\n    plot.hooks.processDatapoints.push(function (plot, series, data, datapoints) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        processDatapoints(plot, series, data, datapoints);\n      }\n    });\n    plot.hooks.drawOverlay.push(function (plot, octx) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        drawOverlay(plot, octx);\n      }\n    });\n    plot.hooks.draw.push(function (plot, newCtx) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        draw(plot, newCtx);\n      }\n    });\n\n    function processDatapoints(plot, series, datapoints) {\n      if (!processed) {\n        processed = true;\n        canvas = plot.getCanvas();\n        target = $(canvas).parent();\n        options = plot.getOptions();\n        plot.setData(combine(plot.getData()));\n      }\n    }\n\n    function combine(data) {\n      var total = 0,\n          combined = 0,\n          numCombined = 0,\n          color = options.series.pie.combine.color,\n          newdata = []; // Fix up the raw data from Flot, ensuring the data is numeric\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data; // If the data is an array, we'll assume that it's a standard\n        // Flot x-y pair, and are concerned only with the second value.\n        // Note how we use the original array, rather than creating a\n        // new one; this is more efficient and preserves any extra data\n        // that the user may have stored in higher indexes.\n\n        if ($.isArray(value) && value.length == 1) {\n          value = value[0];\n        }\n\n        if ($.isArray(value)) {\n          // Equivalent to $.isNumeric() but compatible with jQuery < 1.7\n          if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n            value[1] = +value[1];\n          } else {\n            value[1] = 0;\n          }\n        } else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n          value = [1, +value];\n        } else {\n          value = [1, 0];\n        }\n\n        data[i].data = [value];\n      } // Sum up all the slices, so we can calculate percentages for each\n\n\n      for (var i = 0; i < data.length; ++i) {\n        total += data[i].data[0][1];\n      } // Count the number of slices with percentages below the combine\n      // threshold; if it turns out to be just one, we won't combine.\n\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data[0][1];\n\n        if (value / total <= options.series.pie.combine.threshold) {\n          combined += value;\n          numCombined++;\n\n          if (!color) {\n            color = data[i].color;\n          }\n        }\n      }\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data[0][1];\n\n        if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\n          newdata.push($.extend(data[i], {\n            /* extend to allow keeping all other original data values\n               and using them e.g. in labelFormatter. */\n            data: [[1, value]],\n            color: data[i].color,\n            label: data[i].label,\n            angle: value * Math.PI * 2 / total,\n            percent: value / (total / 100)\n          }));\n        }\n      }\n\n      if (numCombined > 1) {\n        newdata.push({\n          data: [[1, combined]],\n          color: color,\n          label: options.series.pie.combine.label,\n          angle: combined * Math.PI * 2 / total,\n          percent: combined / (total / 100)\n        });\n      }\n\n      return newdata;\n    }\n\n    function draw(plot, newCtx) {\n      if (!target) {\n        return; // if no series were passed\n      }\n\n      var canvasWidth = plot.getPlaceholder().width(),\n          canvasHeight = plot.getPlaceholder().height(),\n          legendWidth = target.children().filter(\".legend\").children().width() || 0;\n      ctx = newCtx; // WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\n      // When combining smaller slices into an 'other' slice, we need to\n      // add a new series.  Since Flot gives plugins no way to modify the\n      // list of series, the pie plugin uses a hack where the first call\n      // to processDatapoints results in a call to setData with the new\n      // list of series, then subsequent processDatapoints do nothing.\n      // The plugin-global 'processed' flag is used to control this hack;\n      // it starts out false, and is set to true after the first call to\n      // processDatapoints.\n      // Unfortunately this turns future setData calls into no-ops; they\n      // call processDatapoints, the flag is true, and nothing happens.\n      // To fix this we'll set the flag back to false here in draw, when\n      // all series have been processed, so the next sequence of calls to\n      // processDatapoints once again starts out with a slice-combine.\n      // This is really a hack; in 0.9 we need to give plugins a proper\n      // way to modify series before any processing begins.\n\n      processed = false; // calculate maximum radius and center point\n\n      maxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n      centerTop = canvasHeight / 2 + options.series.pie.offset.top;\n      centerLeft = canvasWidth / 2;\n\n      if (options.series.pie.offset.left == \"auto\") {\n        if (options.legend.position.match(\"w\")) {\n          centerLeft += legendWidth / 2;\n        } else {\n          centerLeft -= legendWidth / 2;\n        }\n\n        if (centerLeft < maxRadius) {\n          centerLeft = maxRadius;\n        } else if (centerLeft > canvasWidth - maxRadius) {\n          centerLeft = canvasWidth - maxRadius;\n        }\n      } else {\n        centerLeft += options.series.pie.offset.left;\n      }\n\n      var slices = plot.getData(),\n          attempts = 0; // Keep shrinking the pie's radius until drawPie returns true,\n      // indicating that all the labels fit, or we try too many times.\n\n      do {\n        if (attempts > 0) {\n          maxRadius *= REDRAW_SHRINK;\n        }\n\n        attempts += 1;\n        clear();\n\n        if (options.series.pie.tilt <= 0.8) {\n          drawShadow();\n        }\n      } while (!drawPie() && attempts < REDRAW_ATTEMPTS);\n\n      if (attempts >= REDRAW_ATTEMPTS) {\n        clear();\n        target.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n      }\n\n      if (plot.setSeries && plot.insertLegend) {\n        plot.setSeries(slices);\n        plot.insertLegend();\n      } // we're actually done at this point, just defining internal functions at this point\n\n\n      function clear() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        target.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n      }\n\n      function drawShadow() {\n        var shadowLeft = options.series.pie.shadow.left;\n        var shadowTop = options.series.pie.shadow.top;\n        var edge = 10;\n        var alpha = options.series.pie.shadow.alpha;\n        var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n        if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n          return; // shadow would be outside canvas, so don't draw it\n        }\n\n        ctx.save();\n        ctx.translate(shadowLeft, shadowTop);\n        ctx.globalAlpha = alpha;\n        ctx.fillStyle = \"#000\"; // center and rotate to starting position\n\n        ctx.translate(centerLeft, centerTop);\n        ctx.scale(1, options.series.pie.tilt); //radius -= edge;\n\n        for (var i = 1; i <= edge; i++) {\n          ctx.beginPath();\n          ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n          ctx.fill();\n          radius -= i;\n        }\n\n        ctx.restore();\n      }\n\n      function drawPie() {\n        var startAngle = Math.PI * options.series.pie.startAngle;\n        var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius; // center and rotate to starting position\n\n        ctx.save();\n        ctx.translate(centerLeft, centerTop);\n        ctx.scale(1, options.series.pie.tilt); //ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\n        // draw slices\n\n        ctx.save();\n        var currentAngle = startAngle;\n\n        for (var i = 0; i < slices.length; ++i) {\n          slices[i].startAngle = currentAngle;\n          drawSlice(slices[i].angle, slices[i].color, true);\n        }\n\n        ctx.restore(); // draw slice outlines\n\n        if (options.series.pie.stroke.width > 0) {\n          ctx.save();\n          ctx.lineWidth = options.series.pie.stroke.width;\n          currentAngle = startAngle;\n\n          for (var i = 0; i < slices.length; ++i) {\n            drawSlice(slices[i].angle, options.series.pie.stroke.color, false);\n          }\n\n          ctx.restore();\n        } // draw donut hole\n\n\n        drawDonutHole(ctx);\n        ctx.restore(); // Draw the labels, returning true if they fit within the plot\n\n        if (options.series.pie.label.show) {\n          return drawLabels();\n        } else return true;\n\n        function drawSlice(angle, color, fill) {\n          if (angle <= 0 || isNaN(angle)) {\n            return;\n          }\n\n          if (fill) {\n            ctx.fillStyle = color;\n          } else {\n            ctx.strokeStyle = color;\n            ctx.lineJoin = \"round\";\n          }\n\n          ctx.beginPath();\n\n          if (Math.abs(angle - Math.PI * 2) > 0.000000001) {\n            ctx.moveTo(0, 0); // Center of the pie\n          } //ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\n\n\n          ctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);\n          ctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);\n          ctx.closePath(); //ctx.rotate(angle); // This doesn't work properly in Opera\n\n          currentAngle += angle;\n\n          if (fill) {\n            ctx.fill();\n          } else {\n            ctx.stroke();\n          }\n        }\n\n        function drawLabels() {\n          var currentAngle = startAngle;\n          var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n          for (var i = 0; i < slices.length; ++i) {\n            if (slices[i].percent >= options.series.pie.label.threshold * 100) {\n              if (!drawLabel(slices[i], currentAngle, i)) {\n                return false;\n              }\n            }\n\n            currentAngle += slices[i].angle;\n          }\n\n          return true;\n\n          function drawLabel(slice, startAngle, index) {\n            if (slice.data[0][1] == 0) {\n              return true;\n            } // format label text\n\n\n            var lf = options.legend.labelFormatter,\n                text,\n                plf = options.series.pie.label.formatter;\n\n            if (lf) {\n              text = lf(slice.label, slice);\n            } else {\n              text = slice.label;\n            }\n\n            if (plf) {\n              text = plf(text, slice);\n            }\n\n            var halfAngle = (startAngle + slice.angle + startAngle) / 2;\n            var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n            var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n            var html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + \"px;left:\" + x + \"px;'>\" + text + \"</span>\";\n            target.append(html);\n            var label = target.children(\"#pieLabel\" + index);\n            var labelTop = y - label.height() / 2;\n            var labelLeft = x - label.width() / 2;\n            label.css(\"top\", labelTop);\n            label.css(\"left\", labelLeft); // check to make sure that the label is not outside the canvas\n\n            if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n              return false;\n            }\n\n            if (options.series.pie.label.background.opacity != 0) {\n              // put in the transparent background separately to avoid blended labels and label boxes\n              var c = options.series.pie.label.background.color;\n\n              if (c == null) {\n                c = slice.color;\n              }\n\n              var pos = \"top:\" + labelTop + \"px;left:\" + labelLeft + \"px;\";\n              $(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + \"px;height:\" + label.height() + \"px;\" + pos + \"background-color:\" + c + \";'></div>\").css(\"opacity\", options.series.pie.label.background.opacity).insertBefore(label);\n            }\n\n            return true;\n          } // end individual label function\n\n        } // end drawLabels function\n\n      } // end drawPie function\n\n    } // end draw function\n    // Placed here because it needs to be accessed from multiple locations\n\n\n    function drawDonutHole(layer) {\n      if (options.series.pie.innerRadius > 0) {\n        // subtract the center\n        layer.save();\n        var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n        layer.globalCompositeOperation = \"destination-out\"; // this does not work with excanvas, but it will fall back to using the stroke color\n\n        layer.beginPath();\n        layer.fillStyle = options.series.pie.stroke.color;\n        layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n        layer.fill();\n        layer.closePath();\n        layer.restore(); // add inner stroke\n\n        layer.save();\n        layer.beginPath();\n        layer.strokeStyle = options.series.pie.stroke.color;\n        layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n        layer.stroke();\n        layer.closePath();\n        layer.restore(); // TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\n      }\n    } //-- Additional Interactive related functions --\n\n\n    function isPointInPoly(poly, pt) {\n      for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {\n        (poly[i][1] <= pt[1] && pt[1] < poly[j][1] || poly[j][1] <= pt[1] && pt[1] < poly[i][1]) && pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0] && (c = !c);\n      }\n\n      return c;\n    }\n\n    function findNearbySlice(mouseX, mouseY) {\n      var slices = plot.getData(),\n          options = plot.getOptions(),\n          radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\n          x,\n          y;\n\n      for (var i = 0; i < slices.length; ++i) {\n        var s = slices[i];\n\n        if (s.pie.show) {\n          ctx.save();\n          ctx.beginPath();\n          ctx.moveTo(0, 0); // Center of the pie\n          //ctx.scale(1, options.series.pie.tilt);\t// this actually seems to break everything when here.\n\n          ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n          ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n          ctx.closePath();\n          x = mouseX - centerLeft;\n          y = mouseY - centerTop;\n\n          if (ctx.isPointInPath) {\n            if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n              ctx.restore();\n              return {\n                datapoint: [s.percent, s.data],\n                dataIndex: 0,\n                series: s,\n                seriesIndex: i\n              };\n            }\n          } else {\n            // excanvas for IE doesn;t support isPointInPath, this is a workaround.\n            var p1X = radius * Math.cos(s.startAngle),\n                p1Y = radius * Math.sin(s.startAngle),\n                p2X = radius * Math.cos(s.startAngle + s.angle / 4),\n                p2Y = radius * Math.sin(s.startAngle + s.angle / 4),\n                p3X = radius * Math.cos(s.startAngle + s.angle / 2),\n                p3Y = radius * Math.sin(s.startAngle + s.angle / 2),\n                p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\n                p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\n                p5X = radius * Math.cos(s.startAngle + s.angle),\n                p5Y = radius * Math.sin(s.startAngle + s.angle),\n                arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\n                arrPoint = [x, y]; // TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\n\n            if (isPointInPoly(arrPoly, arrPoint)) {\n              ctx.restore();\n              return {\n                datapoint: [s.percent, s.data],\n                dataIndex: 0,\n                series: s,\n                seriesIndex: i\n              };\n            }\n          }\n\n          ctx.restore();\n        }\n      }\n\n      return null;\n    }\n\n    function onMouseMove(e) {\n      triggerClickHoverEvent(\"plothover\", e);\n    }\n\n    function onClick(e) {\n      triggerClickHoverEvent(\"plotclick\", e);\n    } // trigger click or hover event (they send the same parameters so we share their code)\n\n\n    function triggerClickHoverEvent(eventname, e) {\n      var offset = plot.offset();\n      var canvasX = parseInt(e.pageX - offset.left);\n      var canvasY = parseInt(e.pageY - offset.top);\n      var item = findNearbySlice(canvasX, canvasY);\n\n      if (options.grid.autoHighlight) {\n        // clear auto-highlights\n        for (var i = 0; i < highlights.length; ++i) {\n          var h = highlights[i];\n\n          if (h.auto == eventname && !(item && h.series == item.series)) {\n            unhighlight(h.series);\n          }\n        }\n      } // highlight the slice\n\n\n      if (item) {\n        highlight(item.series, eventname);\n      } // trigger any hover bind events\n\n\n      var pos = {\n        pageX: e.pageX,\n        pageY: e.pageY\n      };\n      target.trigger(eventname, [pos, item]);\n    }\n\n    function highlight(s, auto) {\n      //if (typeof s == \"number\") {\n      //\ts = series[s];\n      //}\n      var i = indexOfHighlight(s);\n\n      if (i == -1) {\n        highlights.push({\n          series: s,\n          auto: auto\n        });\n        plot.triggerRedrawOverlay();\n      } else if (!auto) {\n        highlights[i].auto = false;\n      }\n    }\n\n    function unhighlight(s) {\n      if (s == null) {\n        highlights = [];\n        plot.triggerRedrawOverlay();\n      } //if (typeof s == \"number\") {\n      //\ts = series[s];\n      //}\n\n\n      var i = indexOfHighlight(s);\n\n      if (i != -1) {\n        highlights.splice(i, 1);\n        plot.triggerRedrawOverlay();\n      }\n    }\n\n    function indexOfHighlight(s) {\n      for (var i = 0; i < highlights.length; ++i) {\n        var h = highlights[i];\n        if (h.series == s) return i;\n      }\n\n      return -1;\n    }\n\n    function drawOverlay(plot, octx) {\n      var options = plot.getOptions();\n      var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n      octx.save();\n      octx.translate(centerLeft, centerTop);\n      octx.scale(1, options.series.pie.tilt);\n\n      for (var i = 0; i < highlights.length; ++i) {\n        drawHighlight(highlights[i].series);\n      }\n\n      drawDonutHole(octx);\n      octx.restore();\n\n      function drawHighlight(series) {\n        if (series.angle <= 0 || isNaN(series.angle)) {\n          return;\n        } //octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\n\n\n        octx.fillStyle = \"rgba(255, 255, 255, \" + options.series.pie.highlight.opacity + \")\"; // this is temporary until we have access to parseColor\n\n        octx.beginPath();\n\n        if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\n          octx.moveTo(0, 0); // Center of the pie\n        }\n\n        octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n        octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n        octx.closePath();\n        octx.fill();\n      }\n    }\n  } // end init (plugin body)\n  // define pie specific options and their default values\n\n\n  var options = {\n    series: {\n      pie: {\n        show: false,\n        radius: \"auto\",\n        // actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\n        innerRadius: 0,\n\n        /* for donut */\n        startAngle: 3 / 2,\n        tilt: 1,\n        shadow: {\n          left: 5,\n          // shadow left offset\n          top: 15,\n          // shadow top offset\n          alpha: 0.02 // shadow alpha\n\n        },\n        offset: {\n          top: 0,\n          left: \"auto\"\n        },\n        stroke: {\n          color: \"#fff\",\n          width: 1\n        },\n        label: {\n          show: \"auto\",\n          formatter: function formatter(label, slice) {\n            return \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + \"<br/>\" + Math.round(slice.percent) + \"%</div>\";\n          },\n          // formatter function\n          radius: 1,\n          // radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\n          background: {\n            color: null,\n            opacity: 0\n          },\n          threshold: 0 // percentage at which to hide the label (i.e. the slice is too narrow)\n\n        },\n        combine: {\n          threshold: -1,\n          // percentage at which to combine little slices into one larger slice\n          color: null,\n          // color to give the new slice (auto-generated if null)\n          label: \"Other\" // label to give the new slice\n\n        },\n        highlight: {\n          //color: \"#fff\",\t\t// will add this functionality once parseColor is available\n          opacity: 0.5\n        }\n      }\n    }\n  };\n  $.plot.plugins.push({\n    init: init,\n    options: options,\n    name: \"pie\",\n    version: \"1.1\"\n  });\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}