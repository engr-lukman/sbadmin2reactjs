{"ast":null,"code":"var _classCallCheck = require(\"/opt/lampp/htdocs/Lukman/sbadmin2reactjs/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/opt/lampp/htdocs/Lukman/sbadmin2reactjs/node_modules/@babel/runtime/helpers/createClass\");\n\n(function () {\n  var helper = require(\"./helper\");\n\n  var sides = 4;\n\n  var MorrisBoard =\n  /*#__PURE__*/\n  function () {\n    \"use strict\";\n\n    function MorrisBoard(size, points) {\n      _classCallCheck(this, MorrisBoard);\n\n      var self = this; // Generate map\n\n      this.pointCount = (points.length - 1) * sides; // Loop trough rows to set their fields\n\n      for (var currRow = 0; currRow < size; currRow++) {\n        // Add all fields of a row to map\n        this.map = this.map.concat(new Array(this.pointCount).fill(function (i) {\n          // Protofill a point on the board\n          return {\n            team: false,\n\n            get surroundings() {\n              var index = self.map.indexOf(this);\n              return self.getSurroundings(index);\n            },\n\n            get position() {\n              return self.getPointPosition(self.map.indexOf(this));\n            },\n\n            get mills() {\n              return self.getMills(self.map.indexOf(this));\n            },\n\n            get sides() {\n              return self.getSides(self.map.indexOf(this));\n            },\n\n            get line() {\n              return self.getLineIndex(self.map.indexOf(this));\n            }\n\n          };\n        }));\n      }\n\n      this.points = points;\n    } // Getter that returns all rows as arrays containing point objects\n\n\n    _createClass(MorrisBoard, [{\n      key: \"getSurroundings\",\n      value: function getSurroundings(index) {\n        var pos = this.getPointPosition(index); // Get the line the point is a part of (If not, false)\n\n        var line = this.getLineIndex(index);\n        /*\n         NOTE\n        Please remember that the coordinate system behind this is circular. That means the \"left\" surrounding is not always the left you see on your screen. Also \"up\" and down are just in relation to the center point of the board\n         */\n\n        return {\n          // Try to add just 1 to the current index. But if such a position would be bigger or equal as the amount of points in the row, we are looking at the last point of a row\n          // Therefore we have to use the first point of row as right surrounding\n          right: pos.position + 1 < this.pointCount ? this.map[index + 1] : this.map[pos.row * this.pointCount + 0],\n          // Same here but in reverse logic with substrating. If such a position is bigger or equal to 0, it is okay. But if not, the current point seems to be the first in row\n          // Therefore we have use the last point of row as left surrounding\n          left: pos.position - 1 >= 0 ? this.map[index - 1] : this.map[pos.row * this.pointCount + this.pointCount - 1],\n          up: typeof line === \"number\" ? index + this.pointCount in this.map ? this.map[index + this.pointCount] : null : null,\n          down: typeof line === \"number\" ? index - this.pointCount in this.map ? this.map[index - this.pointCount] : null : null\n        };\n        return row;\n      }\n    }, {\n      key: \"getPointIndex\",\n      value: function getPointIndex(row, position) {\n        return row * this.pointCount + position;\n      }\n    }, {\n      key: \"getPoint\",\n      value: function getPoint(row, position) {\n        return this.map[this.getPointIndex(row, position)];\n      }\n    }, {\n      key: \"getPointPosition\",\n      value: function getPointPosition(index) {\n        return {\n          row: Math.trunc(index / this.pointCount),\n          position: index % this.pointCount\n        };\n      }\n    }, {\n      key: \"getSides\",\n      value: function getSides(index) {\n        var pos = this.getPointPosition(index);\n        var allSides = [// Primary side is the first side (returns normally by calculating)\n        Math.trunc(pos.position / (this.pointCount / sides)), // Secondary side is the side, that returns when the start point is one less (If this is not same as primary side, the point borders on a second side)\n        Math.trunc(((pos.position - 1 >= 0 ? pos.position : this.pointCount) - 1) / (this.pointCount / sides))];\n        return allSides.filter(function (side, index) {\n          return allSides.indexOf(side, index + 1) == -1;\n        });\n      } // Returns the index of the line a point is part of (If the point is part of it). If not, returns false\n\n    }, {\n      key: \"getLineIndex\",\n      value: function getLineIndex(index) {\n        var point = this.map[index];\n        var pos = this.getPointPosition(index);\n        var pointConnectionIndex = pos.position % (this.pointCount / sides);\n        var connection = this.points[pointConnectionIndex];\n        return connection ? pos.position : false;\n      } // Returns a line's points\n\n    }, {\n      key: \"getLine\",\n      value: function getLine(lineIndex) {\n        if (typeof lineIndex != \"number\") {\n          return false;\n        }\n\n        var rowsCount = this.map.length / this.pointCount;\n        var line = [];\n\n        for (var row = 0; row < rowsCount; row++) {\n          line.push(this.map[row * this.pointCount + lineIndex]);\n        }\n\n        return line;\n      }\n    }, {\n      key: \"getSide\",\n      value: function getSide(sideIndex, row) {\n        // Start point is alway the leftest point on the side\n        var point = this.map[this.pointCount * row + sideIndex * (this.pointCount / sides)]; // Not needed yet because the search starts always at the leftest one\n\n        /*var leftPoints = [];\n        var neighbouringPointLeft = point;\n        while (neighbouringPointLeft.sides.includes(sideIndex)) {\n          leftPoints.push(this.map.indexOf(neighbouringPointLeft));\n          neighbouringPointLeft = neighbouringPointLeft.surroundings.left;\n        }*/\n        // We start at leftest point because of \"left-to-right\"\n        // Array that will be filled with points that are right of the start point\n\n        var rightPoints = []; // Initiale start point as first point (Because the start point also a part of the side)\n\n        var neighbouringPointRight = point; // Loop while the current point ('neighbouringPointRight') is a part of current side we are working with (Part of it's 'sides' property)\n\n        while (neighbouringPointRight.sides.includes(sideIndex)) {\n          // Push current point to the list\n          rightPoints.push(neighbouringPointRight); // Set new point to point right from current point\n\n          neighbouringPointRight = neighbouringPointRight.surroundings.right;\n        } // Point right from last point seems to be not a part of current side\n        // Side list is completed\n        // Returning side list\n\n\n        return rightPoints;\n      }\n    }, {\n      key: \"getMills\",\n      value: function getMills(index) {\n        var _this = this;\n\n        var mills = [];\n        var pos = this.getPointPosition(index);\n        var point = this.map[index]; // Check for horizontal mills\n\n        var horizontalMills = [];\n        point.sides.forEach(function (side) {\n          var sideList = _this.getSide(side, pos.row); // Loop trough all points of the side\n\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = sideList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var currPoint = _step.value;\n\n              // If current point's team does not equal to the team of the point whose side we are stdy here, return because this side cannot contain a mill\n              if (point.team != currPoint.team || !point.team) {\n                // Current point's team is a different one (Contrary team or no team because there is no piece). This side does not contain a mill\n                return;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          horizontalMills.push(sideList);\n        });\n        mills = mills.concat(horizontalMills);\n        var verticalMill; // Get line's object from its index\n\n        var line = this.getLine(point.line); // If this returns a valid object (Otherwise false)\n\n        if (line) {\n          // Anonymous function used here to return when a team does not equals to the required one\n          (function () {\n            // Loop trough points of line and check wether their team equals to the team of the current point\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = line[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var currPoint = _step2.value;\n\n                if (point.team != currPoint.team || !point.team) {\n                  // Different team (false or contrary one), return because\n                  return;\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            verticalMill = line;\n            mills.push(verticalMill);\n          })();\n        }\n\n        return mills;\n      }\n    }, {\n      key: \"set\",\n      value: function set(options) {\n        // Wether all required options exist\n        if (\"team\" in options && \"row\" in options && \"position\" in options) {\n          // Calculate index of field in map\n          var fieldIndex = this.getPointIndex(options.row, options.position); // Set piece on point\n\n          this.map[fieldIndex].team = options.team; // Return the index of the point to use it externaly\n\n          return fieldIndex;\n        }\n      }\n    }, {\n      key: \"move\",\n      value: function move(pos, newPos) {\n        var teamName = this.map[pos].team;\n        this.map[newPos].team = teamName;\n        this.map[pos].team = false;\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(index) {\n        // Just reset the 'team' property\n        this.map[index].team = false;\n      } // Checks wether a given point borders on a second point by looping trough its surroundings\n\n    }, {\n      key: \"rows\",\n      get: function get() {\n        var rows = []; // Loop trough map with 'pointCount' as step size\n        // 'pointCount' represents the amount of points within a row (E.g. 8)\n\n        for (var i = 0; i < this.map.length; i += this.pointCount) {\n          // Push for each row a sliced version of 'map' starting ta row's start index and ending with the last point of the current row\n          rows.push(this.map.slice(i, i + this.pointCount));\n        }\n\n        return rows;\n      }\n    }, {\n      key: \"mills\",\n      get: function get() {\n        var mills = [];\n        this.map.filter(function (point) {\n          return point.team;\n        }).forEach(function (point) {\n          // Filter if a mill already exists in 'mills' array\n          mills = mills.concat(point.mills.filter(function (mill) {\n            // General function that returns wether the current mill is already located within 'mills' array\n            return !function () {\n              // Looping trough 'mills' array and check the mills wether they are qual to the current 'mill'\n              for (var _i = 0; _i < mills.length; _i++) {\n                var currMill = mills[_i];\n\n                // Function that returns wether the current 'mill' is exactly the same as the current mill ('currMill') of 'mills' array\n                var isMill = function () {\n                  // Looping trough all points within the current mill\n                  for (var i = 0; i < currMill.length; i++) {\n                    // If there exist a point that's equivalent point in 'mill' does not equal with it, this mill cannot be exactly the same\n                    if (currMill[i] != mill[i]) {\n                      return false;\n                    }\n                  } // Obviously, no point in 'currMill' was found that does not eual to its equivalent point in 'mill'\n                  // Therefore, 'currMill' seems to be exactly the same as 'mill'\n\n\n                  return true;\n                }(); // If the current mill 'currMill' seems to be exactly the same as 'mill' we can return a true\n                // if not, the loop goes on to the next mill to check for equivalence with 'mill'\n\n\n                if (isMill) {\n                  return true;\n                }\n              } // Loop was finished and no mill in 'mills' was found that equals to 'mill'\n              // 'mill' seems to be new\n\n\n              return false;\n            }();\n          }));\n        });\n        return mills;\n      }\n    }], [{\n      key: \"isSurrounding\",\n      value: function isSurrounding(point, targetPoint) {\n        // Loop trough a surroundings of the point\n        for (var surroundingPointDirection in point.surroundings) {\n          // Just to exclude prototype properties within the 'surroundings' object\n          if (point.surroundings.hasOwnProperty(surroundingPointDirection)) {\n            // Wether the current surroundings equals to target point\n            if (point.surroundings[surroundingPointDirection] === targetPoint) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n    }]);\n\n    return MorrisBoard;\n  }();\n\n  MorrisBoard.prototype.map = [];\n  module.exports = MorrisBoard;\n})();","map":null,"metadata":{},"sourceType":"script"}